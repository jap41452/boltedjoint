<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Bolted Joint Module — Skeleton (UI + Scaled Drawing)</title>
<style>
  :root{
    --bg:#ffffff;
    --panel:#f5f6f8;
    --card:#ffffff;
    --line:#d7dbe3;
    --text:#111827;
    --muted:#5b6472;
    --accent:#2563eb;
    --ok:#166534;
    --warn:#b45309;
    --err:#b91c1c;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text);}
  #app{height:100%; display:grid; grid-template-columns: 420px 1fr; gap:0; }
  #left{background:var(--panel); border-right:1px solid var(--line); padding:14px 14px 16px; overflow:auto;}
  #right{background:#fff; padding:14px; overflow:auto;}
  h1{font-size:16px; margin:0 0 10px;}
  .sub{color:var(--muted); font-size:12px; margin:0 0 12px;}
  .card{background:var(--card); border:1px solid var(--line); border-radius:12px; padding:12px; margin:10px 0;}
  .card h2{font-size:13px; margin:0 0 10px; color:#0b1220;}
  .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin:8px 0;}
  .row3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; margin:8px 0;}
  label{font-size:12px; color:var(--muted); display:block; margin:0 0 4px;}
  input, select{
    width:100%; box-sizing:border-box;
    border:1px solid var(--line); border-radius:10px;
    padding:8px 10px; font-size:13px; background:#fff; color:var(--text);
  }
  input[type="checkbox"]{width:auto;}
  .inline{display:flex; align-items:center; gap:8px;}
  .btnbar{display:flex; gap:10px; flex-wrap:wrap;}
  button{
    border:1px solid var(--line); background:#fff; color:var(--text);
    border-radius:10px; padding:9px 12px; font-size:13px; cursor:pointer;
  }
  button.primary{background:var(--accent); border-color:var(--accent); color:#fff;}
  button:active{transform:translateY(1px);}
  .small{font-size:12px; color:var(--muted);}
  .table{
    width:100%; border-collapse:collapse; font-size:12px;
    border:1px solid var(--line); border-radius:10px; overflow:hidden;
  }
  .table th,.table td{border-bottom:1px solid var(--line); padding:7px 8px; text-align:left;}
  .table th{background:#f9fafb; color:#111827; font-weight:600;}
  .table tr:last-child td{border-bottom:none;}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--line); color:var(--muted);}
  .status-ok{color:var(--ok); border-color:#b7e0c3; background:#f2fbf5;}
  .status-warn{color:var(--warn); border-color:#f1d6a8; background:#fffbf2;}
  .status-err{color:var(--err); border-color:#f0b4b4; background:#fff5f5;}
  #canvasWrap{
    background:#fff; border:1px solid var(--line);
    border-radius:12px; padding:10px;
  }
  canvas{width:100%; height:420px; display:block;}
  pre{
    font-family:var(--mono); font-size:12px; background:#0b1220; color:#e5e7eb;
    border-radius:12px; padding:12px; overflow:auto; margin:10px 0 0;
  }
  .muted{color:var(--muted);}
  .hr{height:1px; background:var(--line); margin:10px 0;}
  .rightGrid{display:grid; grid-template-columns: 1fr; gap:12px;}
  .note{font-size:12px; color:var(--muted); line-height:1.35;}
</style>
</head>
<body>
<div id="app">
  <!-- LEFT PANEL -->
  <div id="left">
    <h1>Bolted Joint — Preload Sizing (Skeleton)</h1>
    <p class="sub">Single-file UI + scaled joint drawing + data model + calculation pipeline.</p>

    <div class="card">
      <h2>Units & Standard</h2>
      <div class="row">
        <div>
          <div class="inline">
            <input id="isImperial" type="checkbox" checked />
            <label for="isImperial" style="margin:0;">Imperial (in, lbf)</label>
          </div>
          <div class="small">Unchecked = Metric (mm, N)</div>
        </div>
        <div>
          <label>Standard Family</label>
          <select id="boltFamily"></select>
        </div>
      </div>

      <div class="row3">
        <div>
          <label>Thread Series</label>
          <select id="threadSeries">
            <option value="coarse">Coarse</option>
            <option value="fine">Fine</option>
          </select>
        </div>
        <div>
          <label>Grade / Class</label>
          <select id="boltGrade"></select>
        </div>
        <div>
          <label>Bolt Size</label>
          <select id="boltSize"></select>
        </div>
      </div>

      <div class="row3">
        <div>
          <label>Bolt Material E (auto from family; override)</label>
          <input id="boltE" type="number" step="any" />
        </div>
        <div>
          <label>Thread Compliance Factor η (0.80–1.00)</label>
          <input id="etaThread" type="number" step="0.01" value="0.90" min="0.80" max="1.00" />
        </div>
        <div>
          <label>Frustum Half-Angle (deg)</label>
          <input id="frustumAngle" type="number" step="any" value="30" />
        </div>
      </div>
      <div class="note">
        Washer bearing diameter rule: <b>if washer used → OD</b>. If no washer → bolt head / nut bearing diameter (from table placeholders).
      </div>
    </div>

    <div class="card">
      <h2>Geometry Stack</h2>

      <div class="row3">
        <div>
          <label>Head Washer Used?</label>
          <select id="useHeadWasher">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
        <div>
          <label>Head Washer Thickness</label>
          <input id="tHeadWasher" type="number" step="any" value="0.06" />
        </div>
        <div>
          <label>Head Washer OD</label>
          <input id="odHeadWasher" type="number" step="any" value="1.00" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Head Washer Material</label>
          <select id="matHeadWasher"></select>
        </div>
        <div>
          <label>Clamped Members (1–5)</label>
          <select id="numMembers">
            <option>1</option><option selected>2</option><option>3</option><option>4</option><option>5</option>
          </select>
        </div>
      </div>

      <div id="membersArea"></div>

      <div class="row3">
        <div>
          <label>Nut Washer Used?</label>
          <select id="useNutWasher">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
        <div>
          <label>Nut Washer Thickness</label>
          <input id="tNutWasher" type="number" step="any" value="0.06" />
        </div>
        <div>
          <label>Nut Washer OD</label>
          <input id="odNutWasher" type="number" step="any" value="1.00" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Nut Washer Material</label>
          <select id="matNutWasher"></select>
        </div>
        <div>
          <label>Bolt Shank Length (smooth, within grip)</label>
          <input id="Lshank" type="number" step="any" value="0.75" />
        </div>
      </div>

      <div class="small muted">
        Threaded length in grip is derived: <span class="pill">L_thread = L_grip − L_shank_in_grip</span>
      </div>
    </div>

    <div class="card">
      <h2>Loads & Tightening Scatter</h2>

      <div class="row3">
        <div>
          <label>External Load P</label>
          <input id="Pext" type="number" step="any" value="2000" />
        </div>
        <div>
          <label>Target Torque T</label>
          <input id="Ttarget" type="number" step="any" value="120" />
        </div>
        <div>
          <label>Torque Applied At</label>
          <select id="torqueAt">
            <option value="nut" selected>Nut</option>
            <option value="head">Head</option>
          </select>
        </div>
      </div>

      <div class="row3">
        <div>
          <label>Torque Tolerance (±%)</label>
          <input id="Ttol" type="number" step="any" value="10" />
        </div>
        <div>
          <label>μ_thread (min)</label>
          <input id="muTmin" type="number" step="any" value="0.12" />
        </div>
        <div>
          <label>μ_thread (max)</label>
          <input id="muTmax" type="number" step="any" value="0.20" />
        </div>
      </div>

      <div class="row3">
        <div>
          <label>μ_bearing (min)</label>
          <input id="muBmin" type="number" step="any" value="0.12" />
        </div>
        <div></div><div></div>
      </div>

      <div class="row3">
        <div>
          <label>μ_bearing (max)</label>
          <input id="muBmax" type="number" step="any" value="0.20" />
        </div>
        <div></div><div></div>
      </div>

      <div class="row3">
        <div>
          <label>Hole Fit</label>
          <select id="holeFit">
            <option value="normal" selected>Normal (standard)</option>
            <option value="close">Close</option>
            <option value="loose">Loose</option>
            <option value="custom">Custom (override)</option>
          </select>
        </div>
        <div>
          <label>Clearance Hole Dia (override)</label>
          <input id="holeDia" type="number" step="any" placeholder="used only if Hole Fit = Custom" />
        </div>
        <div>
          <label>Proof Utilization Limit</label>
          <input id="proofLimit" type="number" step="any" value="1.00" />
        </div>
      </div>

      <div class="btnbar" style="margin-top:10px;">
        <button class="primary" id="btnScan">Minimum Size Scan</button>
        <button id="btnSolve">Solve / Check Current Size</button>
        <button id="btnRedraw">Redraw Only</button>
        <button id="btnReset">Reset Defaults</button>
      </div>

      <div class="small muted" style="margin-top:6px;">
        Current solver computes geometry, stiffnesses, load fractions, and draws scaled joint immediately.
      </div>
    </div>
  </div>

  <!-- RIGHT PANEL -->
  <div id="right">
    <div class="rightGrid">
      <div id="canvasWrap">
        <div class="inline" style="justify-content:space-between; margin-bottom:8px;">
          <div class="inline" style="gap:10px;">
            <span class="pill" id="unitsPill">Imperial</span>
            <span class="pill" id="familyPill">SAE J429</span>
            <span class="pill" id="sizePill">—</span>
          </div>
          <span class="pill" id="statusPill">Ready</span>
        </div>
        <canvas id="jointCanvas" width="1200" height="520"></canvas>
        <div class="note" style="margin-top:8px;">
          Drawing is to scale based on your inputs (stack thicknesses & bearing diameters). Threads are shown extending into the members (Shigley-style schematic).
        </div>
      </div>

      <div class="card">
        <h2>Computed Summary</h2>
        <table class="table" id="summaryTable">
          <thead><tr><th>Quantity</th><th>Value</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

    </div>
  </div>
</div>

<script>
/* ============================================================
   Material library + standards
   ============================================================ */
const MATERIALS = [
  { key:"steel",      name:"Steel",            E_imp: 30e6, E_met: 200000 },
  { key:"stainless",  name:"Stainless Steel",  E_imp: 28e6, E_met: 193000 },
  { key:"aluminum",   name:"Aluminum",         E_imp: 10e6, E_met:  69000 },
  { key:"gasket",     name:"Gasket (input k)", E_imp: null, E_met: null, needsK:true },
  { key:"oring",      name:"O-ring (input k)", E_imp: null, E_met: null, needsK:true },
  { key:"general",    name:"General (input E)",E_imp: null, E_met: null, needsE:true }
];

const BOLT_FAMILIES = {
  imperial: [
    { key:"sae_j429", name:"SAE J429" },
    { key:"astm",     name:"ASTM (placeholder)" }
  ],
  metric: [
    { key:"iso_metric", name:"ISO Metric" }
  ]
};

const GRADES = {
  sae_j429: [
    { key:"G2", name:"Grade 2",  Sp_imp: 55e3 },
    { key:"G5", name:"Grade 5",  Sp_imp: 85e3 },
    { key:"G8", name:"Grade 8",  Sp_imp: 120e3 }
  ],
  astm: [
    { key:"A325", name:"A325", Sp_imp: 92e3 },
    { key:"A490", name:"A490", Sp_imp: 130e3 }
  ],
  iso_metric: [
    { key:"8.8",  name:"8.8",  Sp_met: 600 },
    { key:"10.9", name:"10.9", Sp_met: 830 },
    { key:"12.9", name:"12.9", Sp_met: 970 }
  ]
};

/* ============================================================
   Bolt geometry generators (EXPANDED: Imperial + ISO Metric)
   ============================================================ */

// Helpers for generated dimensions
const PI = Math.PI;
function avg(a,b){ return 0.5*(a+b); }

// Unified tensile stress area approximation
function At_UN(d, tpi){
  return 0.78539816339 * Math.pow(d - 0.9743/tpi, 2);
}

// ISO metric tensile stress area approximation (common approximation)
function At_ISO(d, p){
  // At ≈ (π/4)*(d - 0.9382*p)^2  (d in mm, p in mm)
  return 0.78539816339 * Math.pow(d - 0.9382*p, 2);
}

// Basic pitch diameter approximation used in both (works well for schematic)
function d2_basic(d, pitch){
  return d - 0.64952 * pitch;
}

/* ----- Imperial head dimensions (approx table) -----
   F = across flats, H = head height (in)
   Used to make drawing look real.
*/
const HEX_HEAD_IMP = {
  "0.25":   { F: avg(0.438,0.428), H: avg(0.163,0.150) },
  "0.3125": { F: avg(0.500,0.489), H: avg(0.211,0.195) },
  "0.375":  { F: avg(0.562,0.551), H: avg(0.243,0.226) },
  "0.4375": { F: avg(0.625,0.612), H: avg(0.291,0.272) },
  "0.5":    { F: avg(0.750,0.736), H: avg(0.323,0.302) },
  "0.5625": { F: avg(0.812,0.798), H: avg(0.371,0.348) },
  "0.625":  { F: avg(0.938,0.922), H: avg(0.403,0.378) },
  "0.75":   { F: avg(1.125,1.100), H: avg(0.483,0.455) },
  "0.875":  { F: avg(1.312,1.285), H: avg(0.563,0.531) },
  "1":      { F: avg(1.500,1.469), H: avg(0.627,0.591) }
};

/* ----- ISO metric head + nut dimensions -----
   s = across flats, k = head height, m = nut height (mm)
   (Typical ISO 4014/4017 & ISO 4032 nominal values)
*/
const ISO_HEX_MET = {
  "6":  { s:10, k:4.0,  m:5.0  },
  "8":  { s:13, k:5.3,  m:6.5  },
  "10": { s:16, k:6.4,  m:8.0  },
  "12": { s:18, k:7.5,  m:10.0 },
  "14": { s:21, k:8.8,  m:11.0 },
  "16": { s:24, k:10.0, m:13.0 },
  "18": { s:27, k:11.5, m:15.0 },
  "20": { s:30, k:12.5, m:16.0 },
  "22": { s:34, k:14.0, m:18.0 },
  "24": { s:36, k:15.0, m:19.0 }
};

// Clearance hole quick rule (schematic). You can later replace with ISO 273 tables.
function holeImpApprox(d){ return d + (d <= 0.5 ? 1/32 : 1/16); }
function holeMetApprox(d){ return d + (d <= 12 ? 1.0 : 2.0); }

function makeImperialBolt(label, d, tpi){
  const pitch = 1/tpi;
  const At = At_UN(d, tpi);
  const d2 = d2_basic(d, pitch);

  const hd = HEX_HEAD_IMP[String(d)] || { F: 1.5*d, H: 0.7*d };
  const headD = hd.F;   // treat as across flats for side view
  const headH = hd.H;

  const nutD  = headD;
  const nutH  = 1.35 * 0.5*d; // decent proportional placeholder if no nut table

  const hole = holeImpApprox(d);

  return { label, d, tpi, pitch, At, d2, headD, headH, nutD, nutH, hole };
}

function buildUNC_UNF(){
  // Expanded common UNC/UNF list up to 1"
  const UNC = [
    ["1/4-20", 0.2500, 20],
    ["5/16-18",0.3125, 18],
    ["3/8-16", 0.3750, 16],
    ["7/16-14",0.4375, 14],
    ["1/2-13", 0.5000, 13],
    ["9/16-12",0.5625, 12],
    ["5/8-11", 0.6250, 11],
    ["3/4-10", 0.7500, 10],
    ["7/8-9",  0.8750, 9],
    ["1-8",    1.0000, 8]
  ];

  const UNF = [
    ["1/4-28", 0.2500, 28],
    ["5/16-24",0.3125, 24],
    ["3/8-24", 0.3750, 24],
    ["7/16-20",0.4375, 20],
    ["1/2-20", 0.5000, 20],
    ["9/16-18",0.5625, 18],
    ["5/8-18", 0.6250, 18],
    ["3/4-16", 0.7500, 16],
    ["7/8-14", 0.8750, 14],
    ["1-12",   1.0000, 12]
  ];

  return {
    coarse: UNC.map(([lab,d,tpi]) => makeImperialBolt(lab,d,tpi)),
    fine:   UNF.map(([lab,d,tpi]) => makeImperialBolt(lab,d,tpi))
  };
}

function makeMetricBolt(label, d, pitch){
  const At = At_ISO(d, pitch);
  const d2 = d2_basic(d, pitch);

  const dim = ISO_HEX_MET[String(d)] || { s: 1.5*d, k: 0.7*d, m: 0.8*d };
  const headD = dim.s;
  const headH = dim.k;
  const nutD  = dim.s;
  const nutH  = dim.m;

  const hole = holeMetApprox(d);

  return { label, d, pitch, At, d2, headD, headH, nutD, nutH, hole };
}

function buildISOmetric(){
  // Expanded typical ISO coarse set
  const coarse = [
    ["M6×1.0",  6, 1.0],
    ["M8×1.25", 8, 1.25],
    ["M10×1.5", 10, 1.5],
    ["M12×1.75",12, 1.75],
    ["M14×2.0", 14, 2.0],
    ["M16×2.0", 16, 2.0],
    ["M18×2.5", 18, 2.5],
    ["M20×2.5", 20, 2.5],
    ["M22×2.5", 22, 2.5],
    ["M24×3.0", 24, 3.0]
  ];

  // Expanded typical ISO fine set (common fine pitches)
  const fine = [
    ["M8×1.0",   8, 1.0],
    ["M10×1.25", 10, 1.25],
    ["M12×1.5",  12, 1.5],
    ["M14×1.5",  14, 1.5],
    ["M16×1.5",  16, 1.5],
    ["M18×1.5",  18, 1.5],
    ["M20×1.5",  20, 1.5],
    ["M22×1.5",  22, 1.5],
    ["M24×2.0",  24, 2.0]
  ];

  return {
    coarse: coarse.map(([lab,d,p]) => makeMetricBolt(lab,d,p)),
    fine:   fine.map(([lab,d,p]) => makeMetricBolt(lab,d,p))
  };
}

// Bolt size tables (generated)
const BOLTS = {
  sae_j429: { coarse: [], fine: [] },
  astm:     { coarse: [], fine: [] },
  iso_metric:{ coarse: [], fine: [] }
};

// Populate from generators
(function buildBoltTables(){
  const imp = buildUNC_UNF();
  BOLTS.sae_j429.coarse = imp.coarse;
  BOLTS.sae_j429.fine   = imp.fine;

  // ASTM placeholder mirrors SAE sizes
  BOLTS.astm.coarse = JSON.parse(JSON.stringify(BOLTS.sae_j429.coarse));
  BOLTS.astm.fine   = JSON.parse(JSON.stringify(BOLTS.sae_j429.fine));

  const met = buildISOmetric();
  BOLTS.iso_metric.coarse = met.coarse;
  BOLTS.iso_metric.fine   = met.fine;
})();

/* ============================================================
   Helpers
   ============================================================ */
const $ = id => document.getElementById(id);

function fmt(x, digits=4){
  if (x === null || x === undefined || Number.isNaN(x)) return "—";
  const ax = Math.abs(x);
  if (ax !== 0 && (ax >= 1e6 || ax < 1e-3)) return x.toExponential(3);
  return Number(x).toFixed(digits).replace(/\.?0+$/,"");
}

function unitLabel(isImp){
  return isImp ? {L:"in", F:"lbf", T:"lbf·in", E:"psi"} : {L:"mm", F:"N", T:"N·mm", E:"MPa"};
}

function materialE(matKey, isImp){
  const m = MATERIALS.find(x => x.key === matKey);
  if(!m) return null;
  return isImp ? m.E_imp : m.E_met;
}

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

// Torque-per-preload factor g(mu_t, mu_b) for thread + bearing
function gThreadBearing(bolt, Db_eff, mu_t, mu_b){
  if(!bolt || !(Db_eff>0)) return null;

  const d2 = bolt.d2;
  const pitch = bolt.pitch;
  if(!(d2>0) || !(pitch>0)) return null;

  const alpha = 30 * Math.PI/180;
  const secA  = 1/Math.cos(alpha);

  const lambda = Math.atan( pitch / (Math.PI*d2) );
  const phi    = Math.atan( mu_t * secA );

  const threadTerm = (d2/2) * Math.tan(lambda + phi);
  const bearTerm   = mu_b * (Db_eff/2);

  const g = threadTerm + bearTerm;
  return (g>0) ? g : null;
}

function torqueBandForState(state, geom){
  const b = state.bolt.data;
  if(!b || !geom) return { feasible:false, reason:"No bolt/geom" };

  const kbOut = calcBoltStiffness(state, geom);
  const kmOut = calcMemberStiffnessShigley(state, geom);
  const C = (kbOut.kb + kmOut.km) > 0 ? kbOut.kb/(kbOut.kb + kmOut.km) : null;
  if(C==null) return { feasible:false, reason:"Bad stiffness" };

  const P = state.loads.P;
  const Fi_req = (1 - C) * P;

  const Fproof = calcProofLoad(state);
  if(!(Fproof>0)) return { feasible:false, reason:"No proof load" };

  const Fi_max_allow = state.loads.proofLimit * Fproof - C * P;
  if(!(Fi_max_allow>0)) return { feasible:false, reason:"No allowable preload" };

  const D_outer = (state.loads.torqueAt === "head") ? geom.Db_top : geom.Db_bot;
  const D_inner = geom.dh;
  const Db_eff  = 0.5*(D_outer + D_inner);

  const tol = state.loads.TtolPct;
  const muT_hi = state.loads.muTmax;
  const muB_hi = state.loads.muBmax;
  const muT_lo = state.loads.muTmin;
  const muB_lo = state.loads.muBmin;

  const g_hi = gThreadBearing(b, Db_eff, muT_hi, muB_hi);
  const g_lo = gThreadBearing(b, Db_eff, muT_lo, muB_lo);

  if(!(g_hi>0) || !(g_lo>0)) return { feasible:false, reason:"Bad g()" };

  const TminReq   = Fi_req       * g_hi / Math.max(1e-12, (1 - tol));
  const TmaxAllow = Fi_max_allow * g_lo / (1 + tol);

  const feasible = (TminReq <= TmaxAllow);
  const Tset = feasible ? 0.5*(TminReq + TmaxAllow) : null;

  return { feasible, reason: feasible ? "OK" : "No feasible torque band", C, Fi_req, Fi_max_allow, Fproof, Db_eff, TminReq, TmaxAllow, Tset };
}

/* ============================================================
   UI construction: member rows + materials
   ============================================================ */
function buildMaterialsSelect(sel){
  sel.innerHTML = "";
  MATERIALS.forEach(m=>{
    const opt = document.createElement("option");
    opt.value = m.key;
    opt.textContent = m.name;
    sel.appendChild(opt);
  });
}

function buildMemberRows(){
  const n = Number($("numMembers").value);
  const wrap = $("membersArea");
  wrap.innerHTML = "";

  for(let i=1;i<=n;i++){
    const card = document.createElement("div");
    card.className = "card";
    card.style.margin = "10px 0 0";
    card.style.borderRadius = "12px";
    card.innerHTML = `
      <h2 style="margin-bottom:8px;">Clamped Member ${i}</h2>
      <div class="row3">
        <div>
          <label>Thickness</label>
          <input id="m_t_${i}" type="number" step="any" value="${i===1?0.25:0.25}">
        </div>
        <div>
          <label>Material</label>
          <select id="m_mat_${i}"></select>
        </div>
        <div>
          <label>Special (k or E)</label>
          <input id="m_extra_${i}" type="number" step="any" placeholder="auto" />
        </div>
      </div>
      <div class="small muted" id="m_help_${i}">For Gasket/O-ring enter k; for General enter E. Otherwise leave blank.</div>
    `;
    wrap.appendChild(card);

    const sel = $("m_mat_"+i);
    buildMaterialsSelect(sel);
    sel.value = "steel";

    sel.addEventListener("change", ()=>{
      updateMemberHelp(i);
      recalcAndDraw(false);
    });
    $("m_t_"+i).addEventListener("input", ()=>recalcAndDraw(false));
    $("m_extra_"+i).addEventListener("input", ()=>recalcAndDraw(false));
    updateMemberHelp(i);
  }
}

function updateMemberHelp(i){
  const key = $("m_mat_"+i).value;
  const m = MATERIALS.find(x=>x.key===key);
  const help = $("m_help_"+i);
  if(m?.needsK) help.textContent = "This layer uses direct stiffness k (force/length). Enter k in 'Special'.";
  else if(m?.needsE) help.textContent = "This layer uses modulus E. Enter E in 'Special'.";
  else help.textContent = "Standard material. Leave 'Special' blank (uses library E).";
}

/* ============================================================
   Units-driven bolt family/grade/size dropdown logic
   ============================================================ */
function rebuildBoltFamilyOptions(){
  const isImp = $("isImperial").checked;
  const famSel = $("boltFamily");
  famSel.innerHTML = "";
  const families = isImp ? BOLT_FAMILIES.imperial : BOLT_FAMILIES.metric;
  families.forEach(f=>{
    const opt = document.createElement("option");
    opt.value = f.key;
    opt.textContent = f.name;
    famSel.appendChild(opt);
  });
  famSel.value = families[0].key;
}

function rebuildGradeOptions(){
  const family = $("boltFamily").value;
  const gradeSel = $("boltGrade");
  gradeSel.innerHTML = "";
  (GRADES[family] || []).forEach(g=>{
    const opt = document.createElement("option");
    opt.value = g.key;
    opt.textContent = g.name;
    gradeSel.appendChild(opt);
  });
  gradeSel.value = (GRADES[family] && GRADES[family][0]) ? GRADES[family][0].key : "";
}

function rebuildSizeOptions(){
  const family = $("boltFamily").value;
  const series = $("threadSeries").value;
  const sizeSel = $("boltSize");
  sizeSel.innerHTML = "";
  const list = (BOLTS[family] && BOLTS[family][series]) ? BOLTS[family][series] : [];
  list.forEach((b,idx)=>{
    const opt = document.createElement("option");
    opt.value = String(idx);
    opt.textContent = b.label;
    sizeSel.appendChild(opt);
  });
  sizeSel.value = list.length ? "0" : "";
}

function updateBoltEDefault(){
  const isImp = $("isImperial").checked;
  $("boltE").value = isImp ? 30e6 : 200000;
}

/* ============================================================
   Read inputs into a single state object
   ============================================================ */
function readState(){
  const isImp = $("isImperial").checked;
  const u = unitLabel(isImp);
  const family = $("boltFamily").value;
  const series = $("threadSeries").value;
  const gradeKey = $("boltGrade").value;

  const sizeIdx = Number($("boltSize").value || 0);
  const bolt = (BOLTS[family] && BOLTS[family][series]) ? BOLTS[family][series][sizeIdx] : null;
  const grade = (GRADES[family] || []).find(g=>g.key===gradeKey) || null;

  const nMembers = Number($("numMembers").value);
  const members = [];
  for(let i=1;i<=nMembers;i++){
    const t = Number($("m_t_"+i).value || 0);
    const matKey = $("m_mat_"+i).value;
    const extra = $("m_extra_"+i).value.trim()==="" ? null : Number($("m_extra_"+i).value);
    members.push({ t, matKey, extra });
  }

  return {
    units: isImp ? "imperial" : "metric",
    u,

    bolt: {
      family, series, gradeKey,
      sizeIdx,
      data: bolt,
      grade: grade,
      E: Number($("boltE").value || (isImp ? 30e6 : 200000)),
      etaThread: clamp(Number($("etaThread").value || 0.90), 0.80, 1.00)
    },
    geom: {
      frustumAngleDeg: Number($("frustumAngle").value || 30),
      useHeadWasher: $("useHeadWasher").value === "yes",
      tHeadWasher: Number($("tHeadWasher").value || 0),
      odHeadWasher: Number($("odHeadWasher").value || 0),
      matHeadWasher: $("matHeadWasher").value,

      useNutWasher: $("useNutWasher").value === "yes",
      tNutWasher: Number($("tNutWasher").value || 0),
      odNutWasher: Number($("odNutWasher").value || 0),
      matNutWasher: $("matNutWasher").value,

      members,
      Lshank: Number($("Lshank").value || 0)
    },
    loads: {
      P: Number($("Pext").value || 0),
      T: Number($("Ttarget").value || 0),
      torqueAt: $("torqueAt").value,
      TtolPct: Number($("Ttol").value || 0) / 100,
      muTmin: Number($("muTmin").value || 0),
      muTmax: Number($("muTmax").value || 0),
      muBmin: Number($("muBmin").value || 0),
      muBmax: Number($("muBmax").value || 0),

      holeFit: $("holeFit").value,

      holeDiaOverride: $("holeDia").value.trim()==="" ? null : Number($("holeDia").value),
      proofLimit: Number($("proofLimit").value || 1.0)
    }
  };
}

/* ============================================================
   Derived geometry & stiffness
   ============================================================ */
function deriveGeometry(state){
  const b = state.bolt.data;
  if(!b) return null;

  const tHW = state.geom.useHeadWasher ? state.geom.tHeadWasher : 0;
  const tNW = state.geom.useNutWasher  ? state.geom.tNutWasher  : 0;
  const tMembers = state.geom.members.reduce((s,m)=>s + (m.t||0), 0);
  const Lg = tHW + tMembers + tNW;

  const Db_top = state.geom.useHeadWasher ? state.geom.odHeadWasher : b.headD;
  const Db_bot = state.geom.useNutWasher  ? state.geom.odNutWasher  : b.nutD;

  let dh;
  if (state.loads.holeFit === "custom") {
    dh = (state.loads.holeDiaOverride !== null) ? state.loads.holeDiaOverride : (b.holeNormal ?? b.hole);
  } else if (state.loads.holeFit === "close") {
    dh = b.holeClose ?? b.holeNormal ?? b.hole;
  } else if (state.loads.holeFit === "loose") {
    dh = b.holeLoose ?? b.holeNormal ?? b.hole;
  } else {
    dh = b.holeNormal ?? b.hole;
  }

  const Lsh = clamp(state.geom.Lshank, 0, Lg);
  const Lth = Math.max(0, Lg - Lsh);

  return { Lg, tHW, tNW, tMembers, Db_top, Db_bot, dh, Lsh, Lth };
}

function calcBoltStiffness(state, geom){
  const b = state.bolt.data;
  const E = state.bolt.E;
  if(!b || !geom) return null;

  const d = b.d;
  const A_shank = Math.PI * d*d / 4;

  const At = b.At;
  const eta = (state?.bolt?.etaThread != null) ? state.bolt.etaThread : 0.90;
  const At_eff = eta * At;

  const comp = (geom.Lsh)/(A_shank*E) + (geom.Lth)/(At_eff*E);
  const kb = comp > 0 ? 1/comp : Infinity;

  return { kb, A_shank, At, eta, At_eff };
}

// ---- Shigley 30° frustum member stiffness (layered, two-sided) ----
function calcMemberStiffnessShigley(state, geom){
  const isImp = state.units === "imperial";
  const alpha = (state.geom.frustumAngleDeg || 30) * Math.PI/180;
  const tanA  = Math.tan(alpha);
  const dh    = geom.dh;

  const layers = [];
  if(state.geom.useHeadWasher && geom.tHW > 0){
    layers.push(makeLayer(state.geom.tHeadWasher, state.geom.matHeadWasher, null, isImp, "Head washer"));
  }
  state.geom.members.forEach((m,i)=>{
    layers.push(makeLayer(m.t, m.matKey, m.extra, isImp, `Member ${i+1}`));
  });
  if(state.geom.useNutWasher && geom.tNW > 0){
    layers.push(makeLayer(state.geom.tNutWasher, state.geom.matNutWasher, null, isImp, "Nut washer"));
  }

  const Lg = geom.Lg;
  const half = 0.5*Lg;

  const topRes = complianceHalf_FromTop(layers, half, geom.Db_top, dh, tanA);
  const botRes = complianceHalf_FromBottom(layers, half, geom.Db_bot, dh, tanA);

  const comp = topRes.comp + botRes.comp;
  const km = comp > 0 ? 1/comp : Infinity;

  return { km, compliance: comp, comp_top: topRes.comp, comp_bot: botRes.comp, Dmid_top: topRes.Dend, Dmid_bot: botRes.Dend };
}

function makeLayer(t, matKey, extra, isImp, name){
  const mat = MATERIALS.find(x=>x.key===matKey) || {};
  const layer = { name, t: Number(t||0), matKey, kind: "E", E: null, k: null };
  if(layer.t <= 0) return layer;

  if(mat.needsK){
    layer.kind = "k";
    layer.k = (extra!==null && isFinite(extra) && extra>0) ? Number(extra) : null;
    return layer;
  }

  layer.kind = "E";
  if(mat.needsE){
    layer.E = (extra!==null && isFinite(extra) && extra>0) ? Number(extra) : null;
  } else {
    layer.E = materialE(matKey, isImp);
  }
  return layer;
}

function complianceHalf_FromTop(layers, half, Db, dh, tanA){
  let depth = 0;
  let comp = 0;

  for(const L of layers){
    if(depth >= half) break;
    const t = L.t || 0;
    if(t <= 0) continue;

    const seg = Math.min(t, half - depth);
    if(L.kind === "k"){
      const kFull = L.k;
      comp += (kFull && kFull>0) ? (seg/t)*(1/kFull) : 1e6*(seg/t);
    } else {
      const E = L.E;
      if(E && E>0){
        const x0 = depth;
        const x1 = depth + seg;
        const D0 = Db + 2*x0*tanA;
        const D1 = Db + 2*x1*tanA;
        comp += frustumCompliance(E, dh, D0, D1, tanA);
      }
    }
    depth += seg;
  }

  const Dend = Db + 2*half*tanA;
  return { comp, Dend };
}

function complianceHalf_FromBottom(layers, half, Db, dh, tanA){
  let depth = 0;
  let comp = 0;

  for(let idx=layers.length-1; idx>=0; idx--){
    if(depth >= half) break;
    const L = layers[idx];
    const t = L.t || 0;
    if(t <= 0) continue;

    const seg = Math.min(t, half - depth);
    if(L.kind === "k"){
      const kFull = L.k;
      comp += (kFull && kFull>0) ? (seg/t)*(1/kFull) : 1e6*(seg/t);
    } else {
      const E = L.E;
      if(E && E>0){
        const x0 = depth;
        const x1 = depth + seg;
        const D0 = Db + 2*x0*tanA;
        const D1 = Db + 2*x1*tanA;
        comp += frustumCompliance(E, dh, D0, D1, tanA);
      }
    }
    depth += seg;
  }

  const Dend = Db + 2*half*tanA;
  return { comp, Dend };
}

function frustumCompliance(E, dh, D0, D1, tanA){
  if(!(E>0) || !(tanA>0) || !(D0>0) || !(D1>0)) return 0;

  let a0 = D0, a1 = D1;
  if(a1 < a0){ const tmp=a0; a0=a1; a1=tmp; }

  const eps = 1e-12;
  if(dh <= eps){
    return (2/(E*Math.PI*tanA)) * ( (1/a0) - (1/a1) );
  }

  const safe = (D)=> Math.max(D, dh + 1e-9);
  const D0s = safe(a0);
  const D1s = safe(a1);

  const term = Math.log( ((D1s - dh)/(D1s + dh)) / ((D0s - dh)/(D0s + dh)) );
  return (1/(E*Math.PI*dh*tanA)) * term;
}

// Real torque -> preload mapping (thread + bearing)
function calcPreloadBoundsThreadBearing(state, geom){
  const b = state.bolt.data;
  if(!b) return null;

  const T = state.loads.T;
  const tol = state.loads.TtolPct;
  const Tmin = T*(1 - tol);
  const Tmax = T*(1 + tol);

  const D_outer = (state.loads.torqueAt === "head") ? geom.Db_top : geom.Db_bot;
  const D_inner = geom.dh;
  const Db_eff  = 0.5*(D_outer + D_inner);

  const Fmin = torqueToPreloadThreadBearing(Tmin, b, Db_eff, state.loads.muTmax, state.loads.muBmax);
  const Fmax = torqueToPreloadThreadBearing(Tmax, b, Db_eff, state.loads.muTmin, state.loads.muBmin);

  return { Tmin, Tmax, Db_eff, Fmin, Fmax };
}

function torqueToPreloadThreadBearing(T, bolt, Db_eff, mu_t, mu_b){
  if(!(T>=0) || !bolt) return null;

  const d2 = bolt.d2;
  const pitch = bolt.pitch;
  if(!(d2>0) || !(pitch>0) || !(Db_eff>0)) return null;

  const alpha = 30 * Math.PI/180;
  const secA  = 1/Math.cos(alpha);

  const lambda = Math.atan( pitch / (Math.PI*d2) );
  const phi = Math.atan( mu_t * secA );

  const threadTerm = (d2/2) * Math.tan(lambda + phi);
  const bearTerm   = mu_b * (Db_eff/2);
  const denom = threadTerm + bearTerm;
  if(!(denom>0)) return null;

  return T / denom;
}

function calcProofLoad(state){
  const b = state.bolt.data;
  const g = state.bolt.grade;
  if(!b || !g) return null;

  if(state.units === "imperial"){
    const Sp = g.Sp_imp || null;
    return Sp ? Sp*b.At : null;
  } else {
    const Sp = g.Sp_met || null;
    return Sp ? Sp*b.At : null;
  }
}

/* ============================================================
   Solver + output tables
   ============================================================ */
function runSolveForCurrentSelection(){
  const state = readState();
  const ev = evaluateCurrentBolt(state);

  if(!ev.geom){
    setStatus("No bolt selected", "err");
    return;
  }

  let status = "OK";
  let cls = "ok";
  if(ev.sepMargin!=null && ev.sepMargin < 0){ status = "Separates"; cls="err"; }
  else if(ev.proofMargin!=null && ev.proofMargin < 0){ status = "Over proof"; cls="err"; }
  else if(ev.sepMargin!=null && ev.sepMargin < 0.05*Math.max(1, ev.sepReq||1)){ status = "Low sep margin"; cls="warn"; }
  setStatus(status, cls);

  const u = state.u;
  const rows = [
    ["Grip length Lg", `${fmt(ev.geom.Lg)} ${u.L}`],
    ["Shank in grip Lsh", `${fmt(ev.geom.Lsh)} ${u.L}`],
    ["Thread in grip Lth", `${fmt(ev.geom.Lth)} ${u.L}`],

    ["Torque applied at", state.loads.torqueAt === "head" ? "Head" : "Nut"],
    ["Effective bearing dia Db_eff", `${fmt(ev.preload?.Db_eff)} ${u.L}`],

    ["Shank area As", `${fmt(ev.kbOut?.A_shank)} ${u.L}²`],
    ["Tensile stress area At", `${fmt(ev.kbOut?.At)} ${u.L}²`],
    ["Thread compliance η", `${fmt(ev.kbOut?.eta,3)}`],
    ["Effective thread area η·At", `${fmt(ev.kbOut?.At_eff)} ${u.L}²`],

    ["Bolt stiffness kb", `${fmt(ev.kbOut?.kb)} ${u.F}/${u.L}`],
    ["Member stiffness km (Shigley)", `${fmt(ev.kmOut?.km)} ${u.F}/${u.L}`],
    ["Load fraction C", `${fmt(ev.C,5)}`],

    ["Torque Tmin", `${fmt(ev.preload?.Tmin)} ${u.T}`],
    ["Torque Tmax", `${fmt(ev.preload?.Tmax)} ${u.T}`],
    ["Preload Fi,min", `${fmt(ev.preload?.Fmin)} ${u.F}`],
    ["Preload Fi,max", `${fmt(ev.preload?.Fmax)} ${u.F}`],

    ["Separation requirement (1−C)P", `${fmt(ev.sepReq)} ${u.F}`],
    ["Separation margin", `${fmt(ev.sepMargin)} ${u.F}`],

    ["Proof load Fproof", `${fmt(ev.Fproof)} ${u.F}`],
    ["Max bolt load Fi,max + C·P", `${fmt(ev.FbMax)} ${u.F}`],
    ["Proof margin", `${fmt(ev.proofMargin)} ${u.F}`]
  ];
  renderSummary(rows);

  drawJoint(state, ev.geom);
}

function renderSummary(rows){
  const tbody = $("summaryTable").querySelector("tbody");
  tbody.innerHTML = "";
  for(const [k,v] of rows){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${k}</td><td>${v}</td>`;
    tbody.appendChild(tr);
  }
}

function setStatus(text, level){
  const pill = $("statusPill");
  pill.textContent = text;
  pill.className = "pill";
  if(level==="ok") pill.classList.add("status-ok");
  if(level==="warn") pill.classList.add("status-warn");
  if(level==="err") pill.classList.add("status-err");
}

function updateRightPills(){
  const isImp = $("isImperial").checked;
  const fam = $("boltFamily").value;
  const familyName = (BOLT_FAMILIES[isImp?"imperial":"metric"].find(x=>x.key===fam)?.name) || fam;

  const series = $("threadSeries").value;
  const sizeIdx = Number($("boltSize").value || 0);
  const bolt = (BOLTS[fam] && BOLTS[fam][series]) ? BOLTS[fam][series][sizeIdx] : null;

  $("unitsPill").textContent = isImp ? "Imperial" : "Metric";
  $("familyPill").textContent = familyName;
  $("sizePill").textContent = bolt ? bolt.label : "—";
}

/* ============================================================
   Drawing (scaled)
   ============================================================ */
function clipPlateMinusHole(ctx, x, y, w, h, holeX, holeW){
  ctx.beginPath();
  ctx.rect(x, y, w, h);
  ctx.rect(holeX, y, holeW, h);
  ctx.clip("evenodd");
}

function drawJoint(state, geom){
  const c = $("jointCanvas");
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  const pad = 55;
  const W = c.width, H = c.height;
  const cx = W*0.5;

  const b = state.bolt.data;
  if(!b || !geom) return;

  // protrusion beyond nut (Shigley-style). Uses length-units (in or mm).
  const protrudeL = Math.max(0.25 * b.d, 2 * b.pitch);

  const headH = b.headH, nutH = b.nutH;
  const stackH = geom.Lg;
  const totalH = headH + stackH + nutH + protrudeL;

  const topY = pad;
  const botY = H - pad;
  const availH = botY - topY;

  const maxD = Math.max(b.headD, b.nutD, geom.Db_top, geom.Db_bot, b.d);
  const availX = W - 2*pad;

  const sY = totalH > 0 ? (availH / totalH) : 1;
  const sX = maxD > 0 ? (0.58*availX / maxD) : 1;
  const s  = Math.min(sX, sY);

  const Dpx = D => D*s;
  const Lpx = L => L*s;

  const yHeadTop  = topY;
  const yHeadBot  = yHeadTop + Lpx(headH);
  const yStackTop = yHeadBot;
  const yStackBot = yStackTop + Lpx(stackH);
  const yNutTop   = yStackBot;
  const yNutBot   = yNutTop + Lpx(nutH);
  const yBoltEnd  = yNutBot + Lpx(protrudeL);

  const plateHalfW = Math.max(Dpx(maxD)*1.15, (W-2*pad)*0.38);
  const holeW = Dpx(geom.dh);

  const shankW  = Dpx(b.d);
  const threadW = Dpx(b.d2);

  const yThreadStart = yStackTop + Lpx(geom.Lsh);
  const yThreadEnd   = yBoltEnd; // show threads through nut + protrusion

  // Layers: washers limited to OD (Option A), members full width
  const layers = [];
  if (state.geom.useHeadWasher && geom.tHW > 0) layers.push({ t: state.geom.tHeadWasher, kind:"washer", od: geom.Db_top });
  state.geom.members.forEach((m,i)=> layers.push({ t:m.t, kind:"member", hatchDir:(i%2===0?1:-1) }));
  if (state.geom.useNutWasher && geom.tNW > 0)  layers.push({ t: state.geom.tNutWasher, kind:"washer", od: geom.Db_bot });

  let y = yStackTop;
  for(const L of layers){
    const h = Lpx(L.t);
    if(h <= 0) continue;

    ctx.save();
    ctx.fillStyle = (L.kind==="washer") ? "#eef2f7" : "#f7f7f7";
    ctx.strokeStyle = "#4b5563";
    ctx.lineWidth = 1;

    const halfW = (L.kind === "washer" && L.od) ? (Dpx(L.od) / 2) : plateHalfW;
    const x0 = cx - halfW;
    const w0 = 2*halfW;
    const holeX = cx - holeW/2;

    ctx.beginPath();
    ctx.rect(x0, y, w0, h);
    ctx.rect(holeX, y, holeW, h);
    ctx.fill("evenodd");
    ctx.stroke();

    if(L.kind === "member"){
      ctx.save();
      clipPlateMinusHole(ctx, x0, y, w0, h, holeX, holeW);
      hatchRect(ctx, x0, y, w0, h, L.hatchDir, 10, "#9ca3af");
      ctx.restore();
    }
    ctx.restore();
    y += h;
  }

  // bolt shank (full length through protrusion)
  ctx.save();
  ctx.fillStyle = "#d6a3a8";
  ctx.strokeStyle = "#7c2d32";
  ctx.lineWidth = 1.25;
  ctx.beginPath();
  ctx.rect(cx - shankW/2, yHeadTop + 2, shankW, (yBoltEnd - yHeadTop) - 4);
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  // threads hatch
  ctx.save();
  ctx.strokeStyle = "#7c2d32";
  ctx.lineWidth = 1;
  const xL = cx - threadW/2;
  const xR = cx + threadW/2;
  for(let yy=yThreadStart; yy<yThreadEnd; yy+=9){
    ctx.beginPath();
    ctx.moveTo(xL, yy);
    ctx.lineTo(xR, yy+9);
    ctx.stroke();
  }
  ctx.restore();

  // thread-start marker + dimensions (inside drawJoint)
  drawThreadStartMarker(ctx, cx, yThreadStart, shankW);
  const xDim = cx + plateHalfW*0.82;
  drawDimBracket(ctx, xDim, yStackTop,    yThreadStart, `Lsh = ${fmt(geom.Lsh)} ${state.u.L}`);
  drawDimBracket(ctx, xDim, yThreadStart, yStackBot,    `Lth = ${fmt(geom.Lth)} ${state.u.L}`);

  // head + nut (professional flat-sided blocks)
  ctx.save();
  ctx.fillStyle = "#c78f95";
  ctx.strokeStyle = "#7c2d32";
  ctx.lineWidth = 1.25;
  drawHexFlatBlock(ctx, cx, yHeadTop, Dpx(b.headD), Lpx(headH));
  drawHexFlatBlock(ctx, cx, yNutTop,  Dpx(b.nutD),  Lpx(nutH));
  ctx.restore();

  // washers / bearing faces
  if(state.geom.useHeadWasher){
    drawRingWasher(ctx, cx, yStackTop, Dpx(geom.Db_top), holeW, Math.max(3, Lpx(state.geom.tHeadWasher)));
  } else {
    drawBearingFace(ctx, cx, yStackTop, Dpx(b.headD)*0.92, shankW);
  }

  if(state.geom.useNutWasher){
    const yW = yStackBot - Math.max(3, Lpx(state.geom.tNutWasher));
    drawRingWasher(ctx, cx, yW, Dpx(geom.Db_bot), holeW, Math.max(3, Lpx(state.geom.tNutWasher)));
  } else {
    drawBearingFace(ctx, cx, yStackBot-2, Dpx(b.nutD)*0.92, shankW);
  }

  // load arrows
  const xA1 = cx - plateHalfW*0.72;
  const xA2 = cx + plateHalfW*0.72;
  drawArrow(ctx, xA1, yStackTop + 8, xA1, yStackTop - 55, "#111827");
  drawArrow(ctx, xA2, yStackTop + 8, xA2, yStackTop - 55, "#111827");
  drawArrow(ctx, xA1, yStackBot - 8, xA1, yStackBot + 55, "#111827");
  drawArrow(ctx, xA2, yStackBot - 8, xA2, yStackBot + 55, "#111827");

  ctx.save();
  ctx.fillStyle = "#111827";
  ctx.font = "16px system-ui";
  ctx.fillText("P", xA1 - 10, yStackTop - 62);
  ctx.fillText("P", xA2 - 10, yStackTop - 62);
  ctx.fillText("P", xA1 - 10, yStackBot + 72);
  ctx.fillText("P", xA2 - 10, yStackBot + 72);
  ctx.restore();
}

// --- Drawing helpers ---
function hatchRect(ctx, x, y, w, h, dir=1, step=10, color="#9ca3af"){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.rect(x,y,w,h);
  ctx.clip();

  const diag = Math.sqrt(w*w + h*h);
  const ang = (dir>=0) ? Math.PI/4 : -Math.PI/4;

  ctx.translate(x + w/2, y + h/2);
  ctx.rotate(ang);

  for(let t=-diag; t<=diag; t+=step){
    ctx.beginPath();
    ctx.moveTo(t, -diag);
    ctx.lineTo(t,  diag);
    ctx.stroke();
  }
  ctx.restore();
}

// flat-sided head/nut with chamfers
function drawHexFlatBlock(ctx, cx, yTop, w, h){
  const x = cx - w/2;
  const y = yTop;
  const c = Math.min(w * 0.12, h * 0.18, 14);

  ctx.beginPath();
  ctx.moveTo(x + c, y);
  ctx.lineTo(x + w - c, y);
  ctx.lineTo(x + w, y + c);
  ctx.lineTo(x + w, y + h - c);
  ctx.lineTo(x + w - c, y + h);
  ctx.lineTo(x + c, y + h);
  ctx.lineTo(x, y + h - c);
  ctx.lineTo(x, y + c);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.save();
  ctx.strokeStyle = "rgba(0,0,0,0.18)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x + w*0.18, y + h*0.12);
  ctx.lineTo(x + w*0.18, y + h*0.88);
  ctx.moveTo(x + w*0.82, y + h*0.12);
  ctx.lineTo(x + w*0.82, y + h*0.88);
  ctx.stroke();
  ctx.restore();
}

function drawRingWasher(ctx, cx, yTop, ODpx, holeWpx, tpx){
  ctx.save();
  ctx.fillStyle = "#e5e7eb";
  ctx.strokeStyle = "#4b5563";
  ctx.lineWidth = 1;

  ctx.beginPath();
  ctx.rect(cx - ODpx/2, yTop, ODpx, tpx);
  ctx.fill();
  ctx.stroke();

  ctx.globalCompositeOperation = "destination-out";
  ctx.fillRect(cx - holeWpx/2, yTop, holeWpx, tpx);
  ctx.globalCompositeOperation = "source-over";
  ctx.restore();
}

function drawBearingFace(ctx, cx, yAt, faceW, holeW){
  ctx.save();
  ctx.strokeStyle = "#4b5563";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(cx - faceW/2, yAt);
  ctx.lineTo(cx - holeW/2, yAt);
  ctx.moveTo(cx + holeW/2, yAt);
  ctx.lineTo(cx + faceW/2, yAt);
  ctx.stroke();
  ctx.restore();
}

function drawThreadStartMarker(ctx, cx, y, shankW, color="#111827"){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.25;
  ctx.beginPath();
  ctx.moveTo(cx - shankW*0.65, y);
  ctx.lineTo(cx + shankW*0.65, y);
  ctx.stroke();
  ctx.restore();
}

function drawDimBracket(ctx, x, y0, y1, label, color="#111827"){
  const top = Math.min(y0,y1), bot = Math.max(y0,y1);
  const cap = 7;

  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 1;

  ctx.beginPath();
  ctx.moveTo(x, top);
  ctx.lineTo(x, bot);
  ctx.moveTo(x-cap, top);
  ctx.lineTo(x+cap, top);
  ctx.moveTo(x-cap, bot);
  ctx.lineTo(x+cap, bot);
  ctx.stroke();

  ctx.font = "13px system-ui";
  ctx.textBaseline = "middle";
  ctx.fillText(label, x + 10, (top+bot)/2);
  ctx.restore();
}

function drawArrow(ctx, x1,y1,x2,y2, color="#111827"){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 2;

  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.stroke();

  const ang = Math.atan2(y2-y1, x2-x1);
  const head = 10;
  ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2 - head*Math.cos(ang - Math.PI/6), y2 - head*Math.sin(ang - Math.PI/6));
  ctx.lineTo(x2 - head*Math.cos(ang + Math.PI/6), y2 - head*Math.sin(ang + Math.PI/6));
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

/* ============================================================
   Event wiring
   ============================================================ */
function recalcAndDraw(runSolve){
  updateRightPills();
  const state = readState();
  const geom = deriveGeometry(state);
  if(geom) drawJoint(state, geom);
  if(runSolve) runSolveForCurrentSelection();
}

function resetDefaults(){
  $("isImperial").checked = true;

  rebuildBoltFamilyOptions();
  rebuildGradeOptions();
  $("threadSeries").value = "coarse";
  rebuildSizeOptions();

  $("useHeadWasher").value = "yes";
  $("tHeadWasher").value = "0.06";
  $("odHeadWasher").value = "1.00";
  $("matHeadWasher").value = "steel";

  $("numMembers").value = "2";
  buildMemberRows();

  $("useNutWasher").value = "yes";
  $("tNutWasher").value = "0.06";
  $("odNutWasher").value = "1.00";
  $("matNutWasher").value = "steel";

  $("Lshank").value = "0.75";

  $("Pext").value = "2000";
  $("Ttarget").value = "120";
  $("Ttol").value = "10";
  $("muTmin").value = "0.12";
  $("muTmax").value = "0.20";
  $("muBmin").value = "0.12";
  $("muBmax").value = "0.20";

  $("holeFit").value = "normal";
  $("holeDia").value = "";

  $("proofLimit").value = "1.00";

  $("frustumAngle").value = "30";
  $("torqueAt").value = "nut";
  $("etaThread").value = "0.90";
  updateBoltEDefault();

  setStatus("Ready", "ok");
  recalcAndDraw(false);
}

function bindEvents(){
  $("isImperial").addEventListener("change", ()=>{
    rebuildBoltFamilyOptions();
    rebuildGradeOptions();
    rebuildSizeOptions();
    updateBoltEDefault();

    if($("isImperial").checked){
      $("tHeadWasher").value = "0.06";
      $("odHeadWasher").value = "1.00";
      $("tNutWasher").value = "0.06";
      $("odNutWasher").value = "1.00";
      $("Lshank").value = "0.75";
      $("Pext").value = "2000";
      $("Ttarget").value = "120";
    } else {
      $("tHeadWasher").value = "1.5";
      $("odHeadWasher").value = "24";
      $("tNutWasher").value = "1.5";
      $("odNutWasher").value = "24";
      $("Lshank").value = "20";
      $("Pext").value = "9000";
      $("Ttarget").value = "14000";
    }

    recalcAndDraw(false);
  });

  $("boltFamily").addEventListener("change", ()=>{
    rebuildGradeOptions();
    rebuildSizeOptions();
    updateBoltEDefault();
    recalcAndDraw(false);
  });

  $("threadSeries").addEventListener("change", ()=>{
    rebuildSizeOptions();
    recalcAndDraw(false);
  });

  $("boltGrade").addEventListener("change", ()=>recalcAndDraw(false));
  $("boltSize").addEventListener("change", ()=>recalcAndDraw(false));

  [
    "useHeadWasher","tHeadWasher","odHeadWasher","matHeadWasher",
    "useNutWasher","tNutWasher","odNutWasher","matNutWasher",
    "Lshank","frustumAngle","boltE","etaThread"
  ].forEach(id=>{
    $(id).addEventListener("input", ()=>recalcAndDraw(false));
    $(id).addEventListener("change", ()=>recalcAndDraw(false));
  });

  $("numMembers").addEventListener("change", ()=>{
    buildMemberRows();
    recalcAndDraw(false);
  });

  ["Pext","Ttarget","torqueAt","Ttol","muTmin","muTmax","muBmin","muBmax","holeFit","holeDia","proofLimit"]
    .forEach(id=>{
      $(id).addEventListener("input", ()=>recalcAndDraw(false));
      $(id).addEventListener("change", ()=>recalcAndDraw(false));
    });

  $("btnSolve").addEventListener("click", runSolveForCurrentSelection);
  $("btnRedraw").addEventListener("click", ()=>recalcAndDraw(false));
  $("btnReset").addEventListener("click", resetDefaults);

  $("btnScan").addEventListener("click", runSizeScan);
}

/* ============================================================
   Init
   ============================================================ */
(function init(){
  buildMaterialsSelect($("matHeadWasher"));
  buildMaterialsSelect($("matNutWasher"));
  $("matHeadWasher").value = "steel";
  $("matNutWasher").value = "steel";

  rebuildBoltFamilyOptions();
  rebuildGradeOptions();
  rebuildSizeOptions();
  updateBoltEDefault();

  buildMemberRows();
  bindEvents();
  resetDefaults();
})();

function evaluateCurrentBolt(state){
  const geom = deriveGeometry(state);
  if(!geom || !state.bolt.data) return { ok:false, reason:"No bolt/geometry" };

  const kbOut = calcBoltStiffness(state, geom);
  const kmOut = calcMemberStiffnessShigley(state, geom);
  const C = (kbOut.kb + kmOut.km) > 0 ? kbOut.kb/(kbOut.kb + kmOut.km) : null;

  const preload = calcPreloadBoundsThreadBearing(state, geom);
  const Fproof = calcProofLoad(state);

  const P = state.loads.P;
  const sepReq = (C!=null) ? (1-C)*P : null;
  const sepMargin = (preload?.Fmin!=null && sepReq!=null) ? (preload.Fmin - sepReq) : null;

  const FbMax = (preload?.Fmax!=null && C!=null) ? (preload.Fmax + C*P) : null;
  const proofMargin = (Fproof!=null && FbMax!=null) ? (state.loads.proofLimit*Fproof - FbMax) : null;

  const okSep = (sepMargin==null) ? false : (sepMargin >= 0);
  const okProof = (proofMargin==null) ? false : (proofMargin >= 0);
  const ok = okSep && okProof;

  return { ok, geom, kbOut, kmOut, C, preload, Fproof, sepReq, sepMargin, FbMax, proofMargin };
}

function runSizeScan(){
  const base = readState();
  const family = base.bolt.family;
  const series = base.bolt.series;

  const list = (BOLTS[family] && BOLTS[family][series]) ? BOLTS[family][series] : [];
  if(!list.length){
    setStatus("No sizes to scan", "err");
    return;
  }

  const holeOverride = base.loads.holeDiaOverride;

  let bestIdx = null;
  let bestBand = null;

  for(let idx=0; idx<list.length; idx++){
    const state = JSON.parse(JSON.stringify(base));
    state.bolt.sizeIdx = idx;
    state.bolt.data = list[idx];
    state.loads.holeDiaOverride = holeOverride;

    const geom = deriveGeometry(state);
    if(!geom) continue;

    const band = torqueBandForState(state, geom);
    if(band.feasible){
      bestIdx = idx;
      bestBand = band;
      break;
    }
  }

  if(bestIdx === null){
    setStatus("No passing size (scan)", "err");
    return;
  }

  $("boltSize").value = String(bestIdx);
  updateRightPills();

  if(bestBand?.Tset != null){
    $("Ttarget").value = String(bestBand.Tset);
  }

  runSolveForCurrentSelection();
  setStatus(`Scan OK → ${list[bestIdx].label}`, "ok");
}
</script>
</body>
</html>















