<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Bolted Joint Module — Skeleton (UI + Scaled Drawing)</title>
<style>
  :root{
    --bg:#ffffff;
    --panel:#f5f6f8;
    --card:#ffffff;
    --line:#d7dbe3;
    --text:#111827;
    --muted:#5b6472;
    --accent:#2563eb;
    --ok:#166534;
    --warn:#b45309;
    --err:#b91c1c;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }
  html,body{height:100%; margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--text);}
  #app{height:100%; display:grid; grid-template-columns: 420px 1fr; gap:0; }
  #left{background:var(--panel); border-right:1px solid var(--line); padding:14px 14px 16px; overflow:auto;}
  #right{background:#fff; padding:14px; overflow:auto;}
  h1{font-size:16px; margin:0 0 10px;}
  .sub{color:var(--muted); font-size:12px; margin:0 0 12px;}
  .card{background:var(--card); border:1px solid var(--line); border-radius:12px; padding:12px; margin:10px 0;}
  .card h2{font-size:13px; margin:0 0 10px; color:#0b1220;}
  .row{display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin:8px 0;}
  .row3{display:grid; grid-template-columns: 1fr 1fr 1fr; gap:10px; margin:8px 0;}
  label{font-size:12px; color:var(--muted); display:block; margin:0 0 4px;}
  input, select{
    width:100%; box-sizing:border-box;
    border:1px solid var(--line); border-radius:10px;
    padding:8px 10px; font-size:13px; background:#fff; color:var(--text);
  }
  input[type="checkbox"]{width:auto;}
  .inline{display:flex; align-items:center; gap:8px;}
  .btnbar{display:flex; gap:10px; flex-wrap:wrap;}
  button{
    border:1px solid var(--line); background:#fff; color:var(--text);
    border-radius:10px; padding:9px 12px; font-size:13px; cursor:pointer;
  }
  button.primary{background:var(--accent); border-color:var(--accent); color:#fff;}
  button:active{transform:translateY(1px);}
  .small{font-size:12px; color:var(--muted);}
  .table{
    width:100%; border-collapse:collapse; font-size:12px;
    border:1px solid var(--line); border-radius:10px; overflow:hidden;
  }
  .table th,.table td{border-bottom:1px solid var(--line); padding:7px 8px; text-align:left;}
  .table th{background:#f9fafb; color:#111827; font-weight:600;}
  .table tr:last-child td{border-bottom:none;}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid var(--line); color:var(--muted);}
  .status-ok{color:var(--ok); border-color:#b7e0c3; background:#f2fbf5;}
  .status-warn{color:var(--warn); border-color:#f1d6a8; background:#fffbf2;}
  .status-err{color:var(--err); border-color:#f0b4b4; background:#fff5f5;}
  #canvasWrap{ background:#fff; border:1px solid var(--line); border-radius:12px; padding:10px; }
  canvas{width:100%; height:320px; display:block;}
  .muted{color:var(--muted);}
  .rightGrid{display:grid; grid-template-columns: 1fr; gap:12px;}
  .note{font-size:12px; color:var(--muted); line-height:1.35;}
</style>
</head>
<body>
<div id="app">
  <!-- LEFT PANEL -->
  <div id="left">
    <h1>Bolted Joint — Preload Sizing (Skeleton)</h1>
    <p class="sub">Single-file UI + scaled joint drawing + data model + calculation pipeline.</p>

    <div class="card">
      <h2>Units & Standard</h2>
      <div class="row">
        <div>
          <div class="inline">
            <input id="isImperial" type="checkbox" checked />
            <label for="isImperial" style="margin:0;">Imperial (in, lbf)</label>
          </div>
          <div class="small">Unchecked = Metric (mm, N)</div>
        </div>
        <div>
          <label>Standard Family</label>
          <select id="boltFamily"></select>
        </div>
      </div>

      <div class="row3">
        <div>
          <label>Thread Series</label>
          <select id="threadSeries">
            <option value="coarse">Coarse</option>
            <option value="fine">Fine</option>
          </select>
        </div>
        <div>
          <label>Grade / Class</label>
          <select id="boltGrade"></select>
        </div>
        <div>
          <label>Bolt Size</label>
          <select id="boltSize"></select>
        </div>
      </div>

      <div class="row3">
        <div>
          <label>Bolt Material E (auto from family; override)</label>
          <input id="boltE" type="number" step="any" />
        </div>
        <div>
          <label>Thread Compliance Factor η (0.80–1.00)</label>
          <input id="etaThread" type="number" step="0.01" value="0.90" min="0.80" max="1.00" />
        </div>
        <div>
          <label>Frustum Half-Angle (deg)</label>
          <input id="frustumAngle" type="number" step="any" value="30" />
        </div>
      </div>

      <div class="note">
        Washer bearing diameter rule: <b>if washer used → OD</b>. If no washer → bolt head / nut bearing diameter from table.
      </div>
    </div>

    <div class="card">
      <h2>Geometry Stack</h2>

      <div class="row3">
        <div>
          <label>Head Washer Used?</label>
          <select id="useHeadWasher">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
        <div>
          <label>Head Washer Thickness</label>
          <input id="tHeadWasher" type="number" step="any" value="0.06" />
        </div>
        <div>
          <label>Head Washer OD</label>
          <input id="odHeadWasher" type="number" step="any" value="1.00" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Head Washer Material</label>
          <select id="matHeadWasher"></select>
        </div>
        <div>
          <label>Clamped Members (1–5)</label>
          <select id="numMembers">
            <option>1</option><option selected>2</option><option>3</option><option>4</option><option>5</option>
          </select>
        </div>
      </div>

      <div id="membersArea"></div>

      <div class="row3">
        <div>
          <label>Nut Washer Used?</label>
          <select id="useNutWasher">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>
        <div>
          <label>Nut Washer Thickness</label>
          <input id="tNutWasher" type="number" step="any" value="0.06" />
        </div>
        <div>
          <label>Nut Washer OD</label>
          <input id="odNutWasher" type="number" step="any" value="1.00" />
        </div>
      </div>

      <div class="row">
        <div>
          <label>Nut Washer Material</label>
          <select id="matNutWasher"></select>
        </div>
        <div>
          <label>Bolt Shank Length (smooth, within grip)</label>
          <input id="Lshank" type="number" step="any" value="0.75" />
        </div>
      </div>

      <div class="small muted">
        Threaded length in grip is derived: <span class="pill">L_thread = L_grip − L_shank_in_grip</span>
      </div>
    </div>

    <div class="card">
      <h2>Loads & Tightening Scatter</h2>

      <div class="row3">
        <div>
          <label>External Load P</label>
          <input id="Pext" type="number" step="any" value="2000" />
        </div>
        <div>
          <label>Target Torque T</label>
          <input id="Ttarget" type="number" step="any" value="120" />
        </div>
        <div>
          <label>Torque Applied At</label>
          <select id="torqueAt">
            <option value="nut" selected>Nut</option>
            <option value="head">Head</option>
          </select>
        </div>
      </div>

      <div class="row3">
        <div>
          <label>Torque Tolerance (±%)</label>
          <input id="Ttol" type="number" step="any" value="10" />
        </div>
        <div>
          <label>μ_thread (min)</label>
          <input id="muTmin" type="number" step="any" value="0.12" />
        </div>
        <div>
          <label>μ_thread (max)</label>
          <input id="muTmax" type="number" step="any" value="0.20" />
        </div>
      </div>

      <div class="row3">
        <div>
          <label>μ_bearing (min)</label>
          <input id="muBmin" type="number" step="any" value="0.12" />
        </div>
        <div></div><div></div>
      </div>

      <div class="row3">
        <div>
          <label>μ_bearing (max)</label>
          <input id="muBmax" type="number" step="any" value="0.20" />
        </div>
        <div></div><div></div>
      </div>

      <div class="row3">
        <div>
          <label>Hole Fit (table-based)</label>
          <select id="holeFit">
            <option value="close">Close</option>
            <option value="normal" selected>Normal</option>
            <option value="loose">Loose</option>
            <option value="custom">Custom (override)</option>
          </select>
        </div>
        <div>
          <label>Clearance Hole Dia (override)</label>
          <input id="holeDia" type="number" step="any" placeholder="used only if Hole Fit = Custom" />
        </div>
        <div>
          <label>Proof Utilization Limit</label>
          <input id="proofLimit" type="number" step="any" value="1.00" />
        </div>
      </div>

      <div class="btnbar" style="margin-top:10px;">
        <button class="primary" id="btnScan">Minimum Size Scan</button>
        <button id="btnSolve">Solve / Check Current Size</button>
        <button id="btnRedraw">Redraw Only</button>
        <button id="btnReset">Reset Defaults</button>
      </div>

<div class="btnbar" style="margin-top:10px;">
  <button id="btnExportJSON">Export JSON</button>
  <button id="btnImportJSON">Import JSON</button>
  <button id="btnExportCSV">Export CSV</button>
</div>




      <div class="small muted" style="margin-top:6px;">
        Clearance hole is now taken from Close/Normal/Loose tables (metric & inch). Custom overrides the table.
      </div>
    </div>
  </div>

  <!-- RIGHT PANEL -->
  <div id="right">
    <div class="rightGrid">
      <div id="canvasWrap">
        <div class="inline" style="justify-content:space-between; margin-bottom:8px;">
          <div class="inline" style="gap:10px;">
            <span class="pill" id="unitsPill">Imperial</span>
            <span class="pill" id="familyPill">SAE J429</span>
            <span class="pill" id="sizePill">1/2-13</span>
          </div>
          <span class="pill" id="statusPill">Ready</span>
        </div>
        <canvas id="jointCanvas" width="1200" height="420"></canvas>
        <div class="note" style="margin-top:8px;">
          Drawing is to scale based on your inputs (stack thicknesses & bearing diameters). Threads are shown extending into the members and through the nut (Shigley-style schematic).
        </div>
      </div>

      <div class="card">
        <h2>Computed Summary</h2>
        <table class="table" id="summaryTable">
          <thead><tr><th>Quantity</th><th>Value</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>

    </div>
  </div>
</div>

<script>
/* ============================================================
   Placeholder data tables (expand later)
   ============================================================ */

const MATERIALS = [
  { key:"steel",      name:"Steel",            E_imp: 30e6, E_met: 200000 },
  { key:"stainless",  name:"Stainless Steel",  E_imp: 28e6, E_met: 193000 },
  { key:"aluminum",   name:"Aluminum",         E_imp: 10e6, E_met:  69000 },
  { key:"gasket",     name:"Gasket (input k)", E_imp: null, E_met: null, needsK:true },
  { key:"oring",      name:"O-ring (input k)", E_imp: null, E_met: null, needsK:true },
  { key:"general",    name:"General (input E)",E_imp: null, E_met: null, needsE:true }
];

const BOLT_FAMILIES = {
  imperial: [
    { key:"sae_j429", name:"SAE J429" },
    { key:"astm",     name:"ASTM" }
  ],
  metric: [
    { key:"iso_metric", name:"ISO Metric" }
  ]
};

const GRADES = {
  sae_j429: [
    { key:"G2", name:"Grade 2",  Sp_imp: 55e3 },   // psi
    { key:"G5", name:"Grade 5",  Sp_imp: 85e3 },
    { key:"G8", name:"Grade 8",  Sp_imp: 120e3 }
  ],
  astm: [
    { key:"A325", name:"A325", Sp_imp: 92e3 },
    { key:"A490", name:"A490", Sp_imp: 130e3 }
  ],
  iso_metric: [
    { key:"8.8",  name:"8.8",  Sp_met: 600 },     // MPa
    { key:"10.9", name:"10.9", Sp_met: 830 },
    { key:"12.9", name:"12.9", Sp_met: 970 }
  ]
};

/* ============================================================
   Clearance hole tables (Close/Normal/Loose)
   - We store min/max and also a nominal = (min+max)/2 for use.
   - Metric table values from ASME B18.2.8 metric hole clearance chart (commonly aligned with ISO 273 practice classes).  :contentReference[oaicite:2]{index=2}
   - Inch table values from ASME/ANSI clearance hole chart (close/normal/loose). :contentReference[oaicite:3]{index=3}
   ============================================================ */

function holeNom(min, max){ return 0.5*(min + max); }

const HOLES_METRIC = {
  // key is nominal thread diameter in mm (integer or common decimal)
  // values: { close:{min,max}, normal:{min,max}, loose:{min,max} }
  5:  { close:{min:5.3, max:5.3},  normal:{min:5.5, max:5.5},  loose:{min:5.8, max:6.1} },
  6:  { close:{min:6.4, max:6.4},  normal:{min:6.6, max:6.6},  loose:{min:7.0, max:7.36} },
  8:  { close:{min:8.4, max:8.4},  normal:{min:9.0, max:9.0},  loose:{min:10.0,max:10.36} },
  10: { close:{min:10.5,max:10.5}, normal:{min:11.0,max:11.0}, loose:{min:12.0,max:12.43} },
  12: { close:{min:13.0,max:13.0}, normal:{min:13.5,max:13.5}, loose:{min:14.5,max:14.93} },
  14: { close:{min:15.0,max:15.0}, normal:{min:15.5,max:15.5}, loose:{min:16.5,max:16.93} },
  16: { close:{min:17.0,max:17.0}, normal:{min:17.5,max:17.5}, loose:{min:18.5,max:19.02} },
  20: { close:{min:21.0,max:21.0}, normal:{min:22.0,max:22.0}, loose:{min:24.0,max:24.52} },
  24: { close:{min:25.0,max:25.0}, normal:{min:26.0,max:26.0}, loose:{min:28.0,max:28.52} }
};

const HOLES_INCH = {
  // key is nominal bolt diameter in inches as string (matches our bolt label parsing)
  // values: { close:{min,max}, normal:{min,max}, loose:{min,max} }
  "0.2500": { close:{min:0.2570, max:0.2660}, normal:{min:0.2660, max:0.2720}, loose:{min:0.2810, max:0.2900} },
  "0.3125": { close:{min:0.3230, max:0.3320}, normal:{min:0.3390, max:0.3480}, loose:{min:0.3580, max:0.3680} },
  "0.3750": { close:{min:0.3860, max:0.3950}, normal:{min:0.4020, max:0.4110}, loose:{min:0.4210, max:0.4330} },
  "0.4375": { close:{min:0.4500, max:0.4600}, normal:{min:0.4680, max:0.4790}, loose:{min:0.5000, max:0.5120} },
  "0.5000": { close:{min:0.5130, max:0.5240}, normal:{min:0.5310, max:0.5430}, loose:{min:0.5620, max:0.5780} },
  "0.5625": { close:{min:0.5780, max:0.5900}, normal:{min:0.6100, max:0.6250}, loose:{min:0.6560, max:0.6720} },
  "0.6250": { close:{min:0.6440, max:0.6550}, normal:{min:0.6720, max:0.6880}, loose:{min:0.7030, max:0.7190} },
  "0.7500": { close:{min:0.7690, max:0.7810}, normal:{min:0.8120, max:0.8280}, loose:{min:0.8750, max:0.8910} },
  "0.8750": { close:{min:0.9000, max:0.9130}, normal:{min:0.9530, max:0.9690}, loose:{min:1.0000, max:1.0310} },
  "1.0000": { close:{min:1.0250, max:1.0380}, normal:{min:1.0780, max:1.0940}, loose:{min:1.1250, max:1.1560} }
};

// Returns hole diameter (nominal) from tables for the currently selected bolt
function lookupClearanceHoleDia(state, bolt){
  const fit = state.loads.holeFit;
  if(fit === "custom") return null;

  if(state.units === "metric"){
    const key = Number(bolt.d); // our metric d is nominal mm integer for these entries
    const row = HOLES_METRIC[key];
    if(!row) return null;
    const r = row[fit];
    return r ? holeNom(r.min, r.max) : null;
  } else {
    const key = Number(bolt.d).toFixed(4);
    const row = HOLES_INCH[key];
    if(!row) return null;
    const r = row[fit];
    return r ? holeNom(r.min, r.max) : null;
  }
}

/* ============================================================
   Bolt generators (expanded sets)
   - We compute At and d2 from pitch/tpi.
   - Head/nut dims are reasonable placeholders (improve later).
   ============================================================ */

function uncAt(d, tpi){
  // Unified tensile-stress area approximation (in^2): At = (pi/4)*(d - 0.9743/n)^2
  const n = tpi;
  return Math.PI/4 * Math.pow(d - 0.9743/n, 2);
}
function uncD2(d, tpi){
  // pitch diameter approx for UN threads: d2 ≈ d - 0.64952*(1/n)
  return d - 0.64952*(1/tpi);
}
function metricAt(d, pitch){
  // ISO metric tensile-stress area approx (mm^2): At = (pi/4)*(d - 0.9382*p)^2
  return Math.PI/4 * Math.pow(d - 0.9382*pitch, 2);
}
function metricD2(d, pitch){
  // pitch diameter approx: d2 ≈ d - 0.64952*p
  return d - 0.64952*pitch;
}

function inchHexAF(d){
  // common across-flats for hex head cap screws (very typical mapping)
  // (this is NOT the clearance hole standard; it's just for drawing realism)
  const map = {
    0.2500:0.4375, 0.3125:0.5000, 0.3750:0.5625, 0.4375:0.6250, 0.5000:0.7500,
    0.5625:0.8125, 0.6250:0.9375, 0.7500:1.1250, 0.8750:1.3125, 1.0000:1.5000
  };
  const k = Number(d).toFixed(4);
  return map[k] ?? (1.5*d);
}
function inchHeadH(d){ return 0.63*d; } // placeholder
function inchNutH(d){ return 0.80*d; }  // placeholder

function metricHexAF(d){
  const map = {5:8,6:10,8:13,10:16,12:18,14:21,16:24,18:27,20:30,22:34,24:36};
  return map[d] ?? Math.round(1.6*d);
}
function metricHeadH(d){
  const map = {5:3.5,6:4.0,8:5.3,10:6.4,12:7.5,14:8.8,16:10.0,18:11.5,20:12.5,22:14.0,24:15.0};
  return map[d] ?? (0.7*d);
}
function metricNutH(d){
  const map = {5:4.0,6:5.0,8:6.5,10:8.0,12:10.0,14:11.0,16:13.0,18:15.0,20:16.0,22:18.0,24:19.0};
  return map[d] ?? (0.85*d);
}

function makeInchBolt(label, d, tpi, headAF=null, headH=null, nutAF=null, nutH=null){
  const pitch = 1/tpi;
  const headD = headAF ?? inchHexAF(d);
  const nutD  = nutAF  ?? inchHexAF(d);
  return {
    label, d, tpi, pitch,
    At: uncAt(d,tpi),
    d2: uncD2(d,tpi),
    headD, headH: (headH ?? inchHeadH(d)),
    nutD,  nutH:  (nutH  ?? inchNutH(d))
  };
}
function makeMetricBolt(label, d, pitch, headAF=null, headH=null, nutAF=null, nutH=null){
  const headD = headAF ?? metricHexAF(d);
  const nutD  = nutAF  ?? metricHexAF(d);
  return {
    label, d, pitch,
    At: metricAt(d,pitch),
    d2: metricD2(d,pitch),
    headD, headH: (headH ?? metricHeadH(d)),
    nutD,  nutH:  (nutH  ?? metricNutH(d))
  };
}

// Expanded bolt lists
const BOLTS = {
  sae_j429: {
    coarse: [
      makeInchBolt("1/4-20",  0.2500, 20),
      makeInchBolt("5/16-18", 0.3125, 18),
      makeInchBolt("3/8-16",  0.3750, 16),
      makeInchBolt("7/16-14", 0.4375, 14),
      makeInchBolt("1/2-13",  0.5000, 13),
      makeInchBolt("9/16-12", 0.5625, 12),
      makeInchBolt("5/8-11",  0.6250, 11),
      makeInchBolt("3/4-10",  0.7500, 10),
      makeInchBolt("7/8-9",   0.8750, 9),
      makeInchBolt("1-8",     1.0000, 8)
    ],
    fine: [
      makeInchBolt("1/4-28",  0.2500, 28),
      makeInchBolt("5/16-24", 0.3125, 24),
      makeInchBolt("3/8-24",  0.3750, 24),
      makeInchBolt("7/16-20", 0.4375, 20),
      makeInchBolt("1/2-20",  0.5000, 20),
      makeInchBolt("9/16-18", 0.5625, 18),
      makeInchBolt("5/8-18",  0.6250, 18),
      makeInchBolt("3/4-16",  0.7500, 16),
      makeInchBolt("7/8-14",  0.8750, 14),
      makeInchBolt("1-12",    1.0000, 12)
    ]
  },
  astm: { coarse: [], fine: [] },
  iso_metric: {
    coarse: [
      makeMetricBolt("M5×0.8",   5, 0.8),
      makeMetricBolt("M6×1.0",   6, 1.0),
      makeMetricBolt("M8×1.25",  8, 1.25),
      makeMetricBolt("M10×1.5",  10, 1.5),
      makeMetricBolt("M12×1.75", 12, 1.75),
      makeMetricBolt("M14×2.0",  14, 2.0),
      makeMetricBolt("M16×2.0",  16, 2.0),
      makeMetricBolt("M20×2.5",  20, 2.5),
      makeMetricBolt("M24×3.0",  24, 3.0)
    ],
    fine: [
      makeMetricBolt("M8×1.0",   8, 1.0),
      makeMetricBolt("M10×1.25", 10, 1.25),
      makeMetricBolt("M12×1.5",  12, 1.5),
      makeMetricBolt("M14×1.5",  14, 1.5),
      makeMetricBolt("M16×1.5",  16, 1.5),
      makeMetricBolt("M20×1.5",  20, 1.5),
      makeMetricBolt("M24×2.0",  24, 2.0)
    ]
  }
};

// Populate ASTM with SAE sizes 
BOLTS.astm.coarse = JSON.parse(JSON.stringify(BOLTS.sae_j429.coarse));
BOLTS.astm.fine   = JSON.parse(JSON.stringify(BOLTS.sae_j429.fine));

/* ============================================================
   Helpers
   ============================================================ */
const $ = id => document.getElementById(id);

function gThreadBearing(bolt, Db_eff, mu_t, mu_b){
  if(!bolt || !(Db_eff>0)) return null;

  const d2 = bolt.d2;
  const pitch = bolt.pitch;
  if(!(d2>0) || !(pitch>0)) return null;

  const alpha = 30 * Math.PI/180;
  const secA  = 1/Math.cos(alpha);

  const lambda = Math.atan( pitch / (Math.PI*d2) );
  const phi    = Math.atan( mu_t * secA );

  const threadTerm = (d2/2) * Math.tan(lambda + phi);
  const bearTerm   = mu_b * (Db_eff/2);

  const g = threadTerm + bearTerm;
  return (g>0) ? g : null;
}

function torqueBandForState(state, geom){
  const b = state.bolt.data;
  if(!b || !geom) return { feasible:false, reason:"No bolt/geom" };

  const kbOut = calcBoltStiffness(state, geom);
  const kmOut = calcMemberStiffnessShigley(state, geom);
  const C = (kbOut.kb + kmOut.km) > 0 ? kbOut.kb/(kbOut.kb + kmOut.km) : null;
  if(C==null) return { feasible:false, reason:"Bad stiffness" };

  const P = state.loads.P;
  const Fi_req = (1 - C) * P;

  const Fproof = calcProofLoad(state);
  if(!(Fproof>0)) return { feasible:false, reason:"No proof load" };

  const Fi_max_allow = state.loads.proofLimit * Fproof - C * P;
  if(!(Fi_max_allow>0)) return { feasible:false, reason:"No allowable preload" };

  const D_outer = (state.loads.torqueAt === "head") ? geom.Db_top : geom.Db_bot;
  const D_inner = geom.dh;
  const Db_eff  = 0.5*(D_outer + D_inner);

  const tol = state.loads.TtolPct;
  const muT_hi = state.loads.muTmax;
  const muB_hi = state.loads.muBmax;
  const muT_lo = state.loads.muTmin;
  const muB_lo = state.loads.muBmin;

  const g_hi = gThreadBearing(b, Db_eff, muT_hi, muB_hi);
  const g_lo = gThreadBearing(b, Db_eff, muT_lo, muB_lo);

  if(!(g_hi>0) || !(g_lo>0)) return { feasible:false, reason:"Bad g()" };

  const TminReq   = Fi_req       * g_hi / Math.max(1e-12, (1 - tol));
  const TmaxAllow = Fi_max_allow * g_lo / (1 + tol);

  const feasible = (TminReq <= TmaxAllow);
  const Tset = feasible ? 0.5*(TminReq + TmaxAllow) : null;

  return { feasible, reason: feasible ? "OK" : "No feasible torque band", C, Fi_req, Fi_max_allow, Fproof, Db_eff, TminReq, TmaxAllow, Tset };
}

function fmt(x, digits=4){
  if (x === null || x === undefined || Number.isNaN(x)) return "—";
  const ax = Math.abs(x);
  if (ax !== 0 && (ax >= 1e6 || ax < 1e-3)) return x.toExponential(3);
  return Number(x).toFixed(digits).replace(/\.?0+$/,"");
}

function unitLabel(isImp){
  return isImp ? {L:"in", F:"lbf", T:"lbf·in", E:"psi"} : {L:"mm", F:"N", T:"N·mm", E:"MPa"};
}

function materialE(matKey, isImp){
  const m = MATERIALS.find(x => x.key === matKey);
  if(!m) return null;
  return isImp ? m.E_imp : m.E_met;
}

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* ============================================================
   UI construction
   ============================================================ */
function buildMaterialsSelect(sel){
  sel.innerHTML = "";
  MATERIALS.forEach(m=>{
    const opt = document.createElement("option");
    opt.value = m.key;
    opt.textContent = m.name;
    sel.appendChild(opt);
  });
}

function buildMemberRows(){
  const n = Number($("numMembers").value);
  const wrap = $("membersArea");
  wrap.innerHTML = "";

  for(let i=1;i<=n;i++){
    const card = document.createElement("div");
    card.className = "card";
    card.style.margin = "10px 0 0";
    card.style.borderRadius = "12px";
    card.innerHTML = `
      <h2 style="margin-bottom:8px;">Clamped Member ${i}</h2>
      <div class="row3">
        <div>
          <label>Thickness</label>
          <input id="m_t_${i}" type="number" step="any" value="${0.25}">
        </div>
        <div>
          <label>Material</label>
          <select id="m_mat_${i}"></select>
        </div>
        <div>
          <label>Special (k or E)</label>
          <input id="m_extra_${i}" type="number" step="any" placeholder="auto" />
        </div>
      </div>
      <div class="small muted" id="m_help_${i}">For Gasket/O-ring enter k; for General enter E. Otherwise leave blank.</div>
    `;
    wrap.appendChild(card);

    const sel = $("m_mat_"+i);
    buildMaterialsSelect(sel);
    sel.value = "steel";

    sel.addEventListener("change", ()=>{
      updateMemberHelp(i);
      recalcAndDraw(false);
    });
    $("m_t_"+i).addEventListener("input", ()=>recalcAndDraw(false));
    $("m_extra_"+i).addEventListener("input", ()=>recalcAndDraw(false));
    updateMemberHelp(i);
  }
}

function buildMemberRowsWithData(membersData){
  const n = Number($("numMembers").value);
  const wrap = $("membersArea");
  wrap.innerHTML = "";

  for(let i=1;i<=n;i++){
    const memberData = membersData && membersData[i-1] ? membersData[i-1] : null;
    const tVal = memberData ? memberData.t : "0.25";
    const matVal = memberData ? memberData.mat : "steel";
    const extraVal = memberData ? memberData.extra : "";
    
    const card = document.createElement("div");
    card.className = "card";
    card.style.margin = "10px 0 0";
    card.style.borderRadius = "12px";
    card.innerHTML = `
      <h2 style="margin-bottom:8px;">Clamped Member ${i}</h2>
      <div class="row3">
        <div>
          <label>Thickness</label>
          <input id="m_t_${i}" type="number" step="any" value="${tVal}">
        </div>
        <div>
          <label>Material</label>
          <select id="m_mat_${i}"></select>
        </div>
        <div>
          <label>Special (k or E)</label>
          <input id="m_extra_${i}" type="number" step="any" placeholder="auto" value="${extraVal}" />
        </div>
      </div>
      <div class="small muted" id="m_help_${i}">For Gasket/O-ring enter k; for General enter E. Otherwise leave blank.</div>
    `;
    wrap.appendChild(card);

    const sel = $("m_mat_"+i);
    buildMaterialsSelect(sel);
    sel.value = matVal;

    sel.addEventListener("change", ()=>{
      updateMemberHelp(i);
      recalcAndDraw(false);
    });
    $("m_t_"+i).addEventListener("input", ()=>recalcAndDraw(false));
    $("m_extra_"+i).addEventListener("input", ()=>recalcAndDraw(false));
    updateMemberHelp(i);
  }
}


function updateMemberHelp(i){
  const key = $("m_mat_"+i).value;
  const m = MATERIALS.find(x=>x.key===key);
  const help = $("m_help_"+i);
  if(m?.needsK) help.textContent = "This layer uses direct stiffness k (force/length). Enter k in 'Special'.";
  else if(m?.needsE) help.textContent = "This layer uses modulus E. Enter E in 'Special'.";
  else help.textContent = "Standard material. Leave 'Special' blank (uses library E).";
}

/* ============================================================
   Units-driven dropdown logic
   ============================================================ */
function rebuildBoltFamilyOptions(){
  const isImp = $("isImperial").checked;
  const famSel = $("boltFamily");
  famSel.innerHTML = "";
  const families = isImp ? BOLT_FAMILIES.imperial : BOLT_FAMILIES.metric;
  families.forEach(f=>{
    const opt = document.createElement("option");
    opt.value = f.key;
    opt.textContent = f.name;
    famSel.appendChild(opt);
  });
  famSel.value = families[0].key;
}

function rebuildGradeOptions(){
  const family = $("boltFamily").value;
  const gradeSel = $("boltGrade");
  gradeSel.innerHTML = "";
  (GRADES[family] || []).forEach(g=>{
    const opt = document.createElement("option");
    opt.value = g.key;
    opt.textContent = g.name;
    gradeSel.appendChild(opt);
  });
  gradeSel.value = (GRADES[family] && GRADES[family][0]) ? GRADES[family][0].key : "";
}

function rebuildSizeOptions(){
  const family = $("boltFamily").value;
  const series = $("threadSeries").value;
  const sizeSel = $("boltSize");
  sizeSel.innerHTML = "";
  const list = (BOLTS[family] && BOLTS[family][series]) ? BOLTS[family][series] : [];
  list.forEach((b,idx)=>{
    const opt = document.createElement("option");
    opt.value = String(idx);
    opt.textContent = b.label;
    sizeSel.appendChild(opt);
  });
  sizeSel.value = list.length ? "0" : "";
}

function updateBoltEDefault(){
  const isImp = $("isImperial").checked;
  $("boltE").value = isImp ? 30e6 : 200000;
}

/* ============================================================
   Read inputs into state
   ============================================================ */
function readState(){
  const isImp = $("isImperial").checked;
  const u = unitLabel(isImp);
  const family = $("boltFamily").value;
  const series = $("threadSeries").value;
  const gradeKey = $("boltGrade").value;

  const sizeIdx = Number($("boltSize").value || 0);
  const bolt = (BOLTS[family] && BOLTS[family][series]) ? BOLTS[family][series][sizeIdx] : null;
  const grade = (GRADES[family] || []).find(g=>g.key===gradeKey) || null;

  const nMembers = Number($("numMembers").value);
  const members = [];
  for(let i=1;i<=nMembers;i++){
    const t = Number($("m_t_"+i).value || 0);
    const matKey = $("m_mat_"+i).value;
    const extra = $("m_extra_"+i).value.trim()==="" ? null : Number($("m_extra_"+i).value);
    members.push({ t, matKey, extra });
  }

  return {
    units: isImp ? "imperial" : "metric",
    u,
    bolt: {
      family, series, gradeKey,
      sizeIdx,
      data: bolt,
      grade: grade,
      E: Number($("boltE").value || (isImp ? 30e6 : 200000)),
      etaThread: clamp(Number($("etaThread").value || 0.90), 0.80, 1.00)
    },
    geom: {
      frustumAngleDeg: Number($("frustumAngle").value || 30),
      useHeadWasher: $("useHeadWasher").value === "yes",
      tHeadWasher: Number($("tHeadWasher").value || 0),
      odHeadWasher: Number($("odHeadWasher").value || 0),
      matHeadWasher: $("matHeadWasher").value,

      useNutWasher: $("useNutWasher").value === "yes",
      tNutWasher: Number($("tNutWasher").value || 0),
      odNutWasher: Number($("odNutWasher").value || 0),
      matNutWasher: $("matNutWasher").value,

      members,
      Lshank: Number($("Lshank").value || 0)
    },
    loads: {
      P: Number($("Pext").value || 0),
      T: Number($("Ttarget").value || 0),
      torqueAt: $("torqueAt").value,
      TtolPct: Number($("Ttol").value || 0) / 100,
      muTmin: Number($("muTmin").value || 0),
      muTmax: Number($("muTmax").value || 0),
      muBmin: Number($("muBmin").value || 0),
      muBmax: Number($("muBmax").value || 0),

      holeFit: $("holeFit").value,
      holeDiaOverride: $("holeDia").value.trim()==="" ? null : Number($("holeDia").value),

      proofLimit: Number($("proofLimit").value || 1.0)
    }
  };
}

/* ============================================================
   Derived geometry & stiffness
   ============================================================ */
function deriveGeometry(state){
  const b = state.bolt.data;
  if(!b) return null;

  const tHW = state.geom.useHeadWasher ? state.geom.tHeadWasher : 0;
  const tNW = state.geom.useNutWasher  ? state.geom.tNutWasher  : 0;
  const tMembers = state.geom.members.reduce((s,m)=>s + (m.t||0), 0);
  const Lg = tHW + tMembers + tNW;

  const Db_top = state.geom.useHeadWasher ? state.geom.odHeadWasher : b.headD;
  const Db_bot = state.geom.useNutWasher  ? state.geom.odNutWasher  : b.nutD;

  // NEW: table-based clearance hole lookup for Close/Normal/Loose; Custom overrides
  let dh = null;
  if (state.loads.holeFit === "custom") {
    dh = (state.loads.holeDiaOverride !== null) ? state.loads.holeDiaOverride : null;
  } else {
    dh = lookupClearanceHoleDia(state, b);
  }

  // Fallback: if table has no row (e.g., a rare size), use a conservative default = normal ~= d + 0.06d (very rough)
  if(!(dh>0)){
    dh = state.units === "metric" ? (b.d + 1.0) : (b.d + 0.0625);
  }

  const Lsh = clamp(state.geom.Lshank, 0, Lg);
  const Lth = Math.max(0, Lg - Lsh);

  return { Lg, tHW, tNW, tMembers, Db_top, Db_bot, dh, Lsh, Lth };
}

function calcBoltStiffness(state, geom){
  const b = state.bolt.data;
  const E = state.bolt.E;
  if(!b || !geom) return null;

  const d = b.d;
  const A_shank = Math.PI * d*d / 4;

  const At = b.At;
  const eta = (state?.bolt?.etaThread != null) ? state.bolt.etaThread : 0.90;
  const At_eff = eta * At;

  const comp = (geom.Lsh)/(A_shank*E) + (geom.Lth)/(At_eff*E);
  const kb = comp > 0 ? 1/comp : Infinity;

  return { kb, A_shank, At, eta, At_eff };
}

function calcMemberStiffnessShigley(state, geom){
  const isImp = state.units === "imperial";
  const alpha = (state.geom.frustumAngleDeg || 30) * Math.PI/180;
  const tanA  = Math.tan(alpha);
  const dh    = geom.dh;

  const layers = [];
  if(state.geom.useHeadWasher && geom.tHW > 0){
    layers.push(makeLayer(state.geom.tHeadWasher, state.geom.matHeadWasher, null, isImp, "Head washer"));
  }
  state.geom.members.forEach((m,i)=>{
    layers.push(makeLayer(m.t, m.matKey, m.extra, isImp, `Member ${i+1}`));
  });
  if(state.geom.useNutWasher && geom.tNW > 0){
    layers.push(makeLayer(state.geom.tNutWasher, state.geom.matNutWasher, null, isImp, "Nut washer"));
  }

  const Lg = geom.Lg;
  const half = 0.5*Lg;

  const topRes = complianceHalf_FromTop(layers, half, geom.Db_top, dh, tanA);
  const botRes = complianceHalf_FromBottom(layers, half, geom.Db_bot, dh, tanA);

  const comp = topRes.comp + botRes.comp;
  const km = comp > 0 ? 1/comp : Infinity;

  return { km, compliance: comp, comp_top: topRes.comp, comp_bot: botRes.comp, Dmid_top: topRes.Dend, Dmid_bot: botRes.Dend };
}

function makeLayer(t, matKey, extra, isImp, name){
  const mat = MATERIALS.find(x=>x.key===matKey) || {};
  const layer = { name, t: Number(t||0), matKey, kind: "E", E: null, k: null };
  if(layer.t <= 0) return layer;

  if(mat.needsK){
    layer.kind = "k";
    layer.k = (extra!==null && isFinite(extra) && extra>0) ? Number(extra) : null;
    return layer;
  }

  layer.kind = "E";
  if(mat.needsE){
    layer.E = (extra!==null && isFinite(extra) && extra>0) ? Number(extra) : null;
  } else {
    layer.E = materialE(matKey, isImp);
  }
  return layer;
}

function complianceHalf_FromTop(layers, half, Db, dh, tanA){
  let depth = 0;
  let comp = 0;

  for(const L of layers){
    if(depth >= half) break;
    const t = L.t || 0;
    if(t <= 0) continue;

    const seg = Math.min(t, half - depth);
    if(L.kind === "k"){
      const kFull = L.k;
      comp += (kFull && kFull>0) ? (seg/t)*(1/kFull) : 1e6*(seg/t);
    } else {
      const E = L.E;
      if(E && E>0){
        const x0 = depth;
        const x1 = depth + seg;
        const D0 = Db + 2*x0*tanA;
        const D1 = Db + 2*x1*tanA;
        comp += frustumCompliance(E, dh, D0, D1, tanA);
      }
    }
    depth += seg;
  }

  const Dend = Db + 2*half*tanA;
  return { comp, Dend };
}

function complianceHalf_FromBottom(layers, half, Db, dh, tanA){
  let depth = 0;
  let comp = 0;

  for(let idx=layers.length-1; idx>=0; idx--){
    if(depth >= half) break;
    const L = layers[idx];
    const t = L.t || 0;
    if(t <= 0) continue;

    const seg = Math.min(t, half - depth);
    if(L.kind === "k"){
      const kFull = L.k;
      comp += (kFull && kFull>0) ? (seg/t)*(1/kFull) : 1e6*(seg/t);
    } else {
      const E = L.E;
      if(E && E>0){
        const x0 = depth;
        const x1 = depth + seg;
        const D0 = Db + 2*x0*tanA;
        const D1 = Db + 2*x1*tanA;
        comp += frustumCompliance(E, dh, D0, D1, tanA);
      }
    }
    depth += seg;
  }

  const Dend = Db + 2*half*tanA;
  return { comp, Dend };
}

function frustumCompliance(E, dh, D0, D1, tanA){
  if(!(E>0) || !(tanA>0) || !(D0>0) || !(D1>0)) return 0;

  let a0 = D0, a1 = D1;
  if(a1 < a0){ const tmp=a0; a0=a1; a1=tmp; }

  const eps = 1e-12;
  if(dh <= eps){
    return (2/(E*Math.PI*tanA)) * ( (1/a0) - (1/a1) );
  }

  const safe = (D)=> Math.max(D, dh + 1e-9);
  const D0s = safe(a0);
  const D1s = safe(a1);

  const term = Math.log( ((D1s - dh)/(D1s + dh)) / ((D0s - dh)/(D0s + dh)) );
  return (1/(E*Math.PI*dh*tanA)) * term;
}

function calcPreloadBoundsThreadBearing(state, geom){
  const b = state.bolt.data;
  if(!b) return null;

  const T = state.loads.T;
  const tol = state.loads.TtolPct;
  const Tmin = T*(1 - tol);
  const Tmax = T*(1 + tol);

  const D_outer = (state.loads.torqueAt === "head") ? geom.Db_top : geom.Db_bot;
  const D_inner = geom.dh;
  const Db_eff  = 0.5*(D_outer + D_inner);

  const Fmin = torqueToPreloadThreadBearing(Tmin, b, Db_eff, state.loads.muTmax, state.loads.muBmax);
  const Fmax = torqueToPreloadThreadBearing(Tmax, b, Db_eff, state.loads.muTmin, state.loads.muBmin);

  return { Tmin, Tmax, Db_eff, Fmin, Fmax };
}

function torqueToPreloadThreadBearing(T, bolt, Db_eff, mu_t, mu_b){
  if(!(T>=0) || !bolt) return null;

  const d2 = bolt.d2;
  const pitch = bolt.pitch;
  if(!(d2>0) || !(pitch>0) || !(Db_eff>0)) return null;

  const alpha = 30 * Math.PI/180;
  const secA  = 1/Math.cos(alpha);

  const lambda = Math.atan( pitch / (Math.PI*d2) );
  const phi = Math.atan( mu_t * secA );

  const threadTerm = (d2/2) * Math.tan(lambda + phi);
  const bearTerm   = mu_b * (Db_eff/2);
  const denom = threadTerm + bearTerm;
  if(!(denom>0)) return null;

  return T / denom;
}

function calcProofLoad(state){
  const b = state.bolt.data;
  const g = state.bolt.grade;
  if(!b || !g) return null;

  if(state.units === "imperial"){
    const Sp = g.Sp_imp || null;
    return Sp ? Sp*b.At : null;
  } else {
    const Sp = g.Sp_met || null;
    return Sp ? Sp*b.At : null;
  }
}

/* ============================================================
   Solver + output
   ============================================================ */
function runSolveForCurrentSelection(){
  const state = readState();
  const ev = evaluateCurrentBolt(state);

  if(!ev.geom){
    setStatus("No bolt selected", "err");
    return;
  }

  let status = "OK";
  let cls = "ok";
  if(ev.sepMargin!=null && ev.sepMargin < 0){ status = "Separates"; cls="err"; }
  else if(ev.proofMargin!=null && ev.proofMargin < 0){ status = "Over proof"; cls="err"; }
  else if(ev.sepMargin!=null && ev.sepMargin < 0.05*Math.max(1, ev.sepReq||1)){ status = "Low sep margin"; cls="warn"; }
  setStatus(status, cls);

  const u = state.u;
  const rows = [
    ["Grip length Lg", `${fmt(ev.geom.Lg)} ${u.L}`],
    ["Shank in grip Lsh", `${fmt(ev.geom.Lsh)} ${u.L}`],
    ["Thread in grip Lth", `${fmt(ev.geom.Lth)} ${u.L}`],

    ["Clearance hole dia dh", `${fmt(ev.geom.dh)} ${u.L}`],
    ["Hole fit", state.loads.holeFit],

    ["Torque applied at", state.loads.torqueAt === "head" ? "Head" : "Nut"],
    ["Effective bearing dia Db_eff", `${fmt(ev.preload?.Db_eff)} ${u.L}`],

    ["Shank area As", `${fmt(ev.kbOut?.A_shank)} ${u.L}²`],
    ["Tensile stress area At", `${fmt(ev.kbOut?.At)} ${u.L}²`],
    ["Thread compliance η", `${fmt(ev.kbOut?.eta,3)}`],
    ["Effective thread area η·At", `${fmt(ev.kbOut?.At_eff)} ${u.L}²`],

    ["Bolt stiffness kb", `${fmt(ev.kbOut?.kb)} ${u.F}/${u.L}`],
    ["Member stiffness km (Shigley)", `${fmt(ev.kmOut?.km)} ${u.F}/${u.L}`],
    ["Load fraction C", `${fmt(ev.C,5)}`],

    ["Torque Tmin", `${fmt(ev.preload?.Tmin)} ${u.T}`],
    ["Torque Tmax", `${fmt(ev.preload?.Tmax)} ${u.T}`],
    ["Preload Fi,min", `${fmt(ev.preload?.Fmin)} ${u.F}`],
    ["Preload Fi,max", `${fmt(ev.preload?.Fmax)} ${u.F}`],

    ["Separation requirement (1−C)P", `${fmt(ev.sepReq)} ${u.F}`],
    ["Separation margin", `${fmt(ev.sepMargin)} ${u.F}`],

    ["Proof load Fproof", `${fmt(ev.Fproof)} ${u.F}`],
    ["Max bolt load Fi,max + C·P", `${fmt(ev.FbMax)} ${u.F}`],
    ["Proof margin", `${fmt(ev.proofMargin)} ${u.F}`]
  ];
  renderSummary(rows);

  drawJoint(state, ev.geom);
}

function renderSummary(rows){
  const tbody = $("summaryTable").querySelector("tbody");
  tbody.innerHTML = "";
  for(const [k,v] of rows){
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${k}</td><td>${v}</td>`;
    tbody.appendChild(tr);
  }
}

function setStatus(text, level){
  const pill = $("statusPill");
  pill.textContent = text;
  pill.className = "pill";
  if(level==="ok") pill.classList.add("status-ok");
  if(level==="warn") pill.classList.add("status-warn");
  if(level==="err") pill.classList.add("status-err");
}

function updateRightPills(){
  const isImp = $("isImperial").checked;
  const fam = $("boltFamily").value;
  const familyName = (BOLT_FAMILIES[isImp?"imperial":"metric"].find(x=>x.key===fam)?.name) || fam;

  const series = $("threadSeries").value;
  const sizeIdx = Number($("boltSize").value || 0);
  const bolt = (BOLTS[fam] && BOLTS[fam][series]) ? BOLTS[fam][series][sizeIdx] : null;

  $("unitsPill").textContent = isImp ? "Imperial" : "Metric";
  $("familyPill").textContent = familyName;
  $("sizePill").textContent = bolt ? bolt.label : "—";
}

/* ============================================================
   Drawing
   ============================================================ */
function clipPlateMinusHole(ctx, x, y, w, h, holeX, holeW){
  ctx.beginPath();
  ctx.rect(x, y, w, h);
  ctx.rect(holeX, y, holeW, h);
  ctx.clip("evenodd");
}

function drawJoint(state, geom){
  const c = $("jointCanvas");
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);

  const pad = 45;
  const W = c.width, H = c.height;
  const cx = W*0.5;

  const b = state.bolt.data;
  if(!b || !geom) return;

  // Small protrusion beyond nut for realism (Shigley-style)
  const protrudeL = Math.max(0.25 * b.d, 2 * b.pitch); // in or mm

  const headH = b.headH, nutH = b.nutH;
  const stackH = geom.Lg;
  const totalH = headH + stackH + nutH + protrudeL;

  const topY = pad;
  const botY = H - pad;
  const availH = botY - topY;

  const maxD = Math.max(b.headD, b.nutD, geom.Db_top, geom.Db_bot, b.d);
  const availX = W - 2*pad;

  const sY = totalH > 0 ? (availH / totalH) : 1;
  const sX = maxD > 0 ? (0.58*availX / maxD) : 1;
  const s  = Math.min(sX, sY);

  const Dpx = D => D*s;
  const Lpx = L => L*s;

  const yHeadTop  = topY;
  const yHeadBot  = yHeadTop + Lpx(headH);
  const yStackTop = yHeadBot;
  const yStackBot = yStackTop + Lpx(stackH);
  const yNutTop   = yStackBot;
  const yNutBot   = yNutTop + Lpx(nutH);
  const yBoltEnd  = yNutBot + Lpx(protrudeL);

  const plateHalfW = Math.max(Dpx(maxD)*1.5, (W-2*pad)*0.45);  // Wider plates
  const holeW = Dpx(geom.dh);

  const shankW  = Dpx(b.d);
  const threadW = Dpx(b.d2);

  const yThreadStart = yStackTop + Lpx(geom.Lsh);
  const yThreadEnd   = yBoltEnd; // show threads through nut & protrusion

  const layers = [];
  if (state.geom.useHeadWasher && geom.tHW > 0) layers.push({ t: state.geom.tHeadWasher, kind: "washer", od: geom.Db_top });
  state.geom.members.forEach((m,i)=> layers.push({ t: m.t, kind: "member", hatchDir: (i%2===0?1:-1) }));
  if (state.geom.useNutWasher && geom.tNW > 0) layers.push({ t: state.geom.tNutWasher, kind: "washer", od: geom.Db_bot });

  let y = yStackTop;
  for(const L of layers){
    const h = Lpx(L.t);
    if(h <= 0) continue;

    ctx.save();
    ctx.fillStyle = (L.kind==="washer") ? "#eef2f7" : "#f7f7f7";
    ctx.strokeStyle = "#4b5563";
    ctx.lineWidth = 1;

    // Option A: washers only to OD width; members full width
    const halfW = (L.kind === "washer" && L.od) ? (Dpx(L.od) / 2) : plateHalfW;

    const x0 = cx - halfW;
    const w0 = 2*halfW;
    const holeX = cx - holeW/2;

    ctx.beginPath();
    ctx.rect(x0, y, w0, h);
    ctx.rect(holeX, y, holeW, h);
    ctx.fill("evenodd");
    ctx.stroke();

    if(L.kind === "member"){
      ctx.save();
      clipPlateMinusHole(ctx, x0, y, w0, h, holeX, holeW);
      hatchRect(ctx, x0, y, w0, h, L.hatchDir, 10, "#9ca3af");
      ctx.restore();
    }
    ctx.restore();
    y += h;
  }

  // bolt shank
  ctx.save();
  ctx.fillStyle = "#d6a3a8";
  ctx.strokeStyle = "#7c2d32";
  ctx.lineWidth = 1.25;
  ctx.beginPath();
  ctx.rect(cx - shankW/2, yHeadTop + 2, shankW, (yBoltEnd - yHeadTop) - 4);
  ctx.fill();
  ctx.stroke();
  ctx.restore();

  // threads hatch
  ctx.save();
  ctx.strokeStyle = "#7c2d32";
  ctx.lineWidth = 1;
  const xL = cx - threadW/2;
  const xR = cx + threadW/2;
  for(let yy=yThreadStart; yy<yThreadEnd; yy+=9){
    ctx.beginPath();
    ctx.moveTo(xL, yy);
    ctx.lineTo(xR, yy+9);
    ctx.stroke();
  }
  ctx.restore();

  // thread start marker + Lsh/Lth brackets
  drawThreadStartMarker(ctx, cx, yThreadStart, shankW);

  const xDim = cx + plateHalfW*0.82;
  drawDimBracket(ctx, xDim, yStackTop,    yThreadStart, `Lsh = ${fmt(geom.Lsh)} ${state.u.L}`);
  drawDimBracket(ctx, xDim, yThreadStart, yStackBot,    `Lth = ${fmt(geom.Lth)} ${state.u.L}`);

  // head + nut (professional-ish flats)
  ctx.save();
  ctx.fillStyle = "#c78f95";
  ctx.strokeStyle = "#7c2d32";
  ctx.lineWidth = 1.25;
  drawHexFlatBlock(ctx, cx, yHeadTop, Dpx(b.headD), Lpx(headH));
  drawHexFlatBlock(ctx, cx, yNutTop,  Dpx(b.nutD),  Lpx(nutH));
  ctx.restore();

  // washers / bearing faces
  if(state.geom.useHeadWasher){
    drawRingWasher(ctx, cx, yStackTop, Dpx(geom.Db_top), holeW, Math.max(3, Lpx(state.geom.tHeadWasher)));
  } else {
    drawBearingFace(ctx, cx, yStackTop, Dpx(b.headD)*0.92, shankW);
  }

  if(state.geom.useNutWasher){
    const yW = yStackBot - Math.max(3, Lpx(state.geom.tNutWasher));
    drawRingWasher(ctx, cx, yW, Dpx(geom.Db_bot), holeW, Math.max(3, Lpx(state.geom.tNutWasher)));
  } else {
    drawBearingFace(ctx, cx, yStackBot-2, Dpx(b.nutD)*0.92, shankW);
  }

  // load arrows
  const xA1 = cx - plateHalfW*0.72;
  const xA2 = cx + plateHalfW*0.72;
  drawArrow(ctx, xA1, yStackTop + 8, xA1, yStackTop - 55, "#111827");
  drawArrow(ctx, xA2, yStackTop + 8, xA2, yStackTop - 55, "#111827");
  drawArrow(ctx, xA1, yStackBot - 8, xA1, yStackBot + 55, "#111827");
  drawArrow(ctx, xA2, yStackBot - 8, xA2, yStackBot + 55, "#111827");

  ctx.save();
  ctx.fillStyle = "#111827";
  ctx.font = "16px system-ui";
  ctx.fillText("P", xA1 - 10, yStackTop - 62);
  ctx.fillText("P", xA2 - 10, yStackTop - 62);
  ctx.fillText("P", xA1 - 10, yStackBot + 72);
  ctx.fillText("P", xA2 - 10, yStackBot + 72);
  ctx.restore();
}

// helpers
function hatchRect(ctx, x, y, w, h, dir=1, step=10, color="#9ca3af"){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.rect(x,y,w,h);
  ctx.clip();

  const diag = Math.sqrt(w*w + h*h);
  const ang = (dir>=0) ? Math.PI/4 : -Math.PI/4;

  ctx.translate(x + w/2, y + h/2);
  ctx.rotate(ang);

  for(let t=-diag; t<=diag; t+=step){
    ctx.beginPath();
    ctx.moveTo(t, -diag);
    ctx.lineTo(t,  diag);
    ctx.stroke();
  }
  ctx.restore();
}

function drawHexFlatBlock(ctx, cx, yTop, w, h){
  const x = cx - w/2;
  const y = yTop;
  const c = Math.min(w * 0.12, h * 0.18, 14);

  ctx.beginPath();
  ctx.moveTo(x + c, y);
  ctx.lineTo(x + w - c, y);
  ctx.lineTo(x + w, y + c);
  ctx.lineTo(x + w, y + h - c);
  ctx.lineTo(x + w - c, y + h);
  ctx.lineTo(x + c, y + h);
  ctx.lineTo(x, y + h - c);
  ctx.lineTo(x, y + c);
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.save();
  ctx.strokeStyle = "rgba(0,0,0,0.18)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x + w*0.18, y + h*0.12);
  ctx.lineTo(x + w*0.18, y + h*0.88);
  ctx.moveTo(x + w*0.82, y + h*0.12);
  ctx.lineTo(x + w*0.82, y + h*0.88);
  ctx.stroke();
  ctx.restore();
}

function drawRingWasher(ctx, cx, yTop, ODpx, holeWpx, tpx){
  ctx.save();
  ctx.fillStyle = "#e5e7eb";
  ctx.strokeStyle = "#4b5563";
  ctx.lineWidth = 1;

  ctx.beginPath();
  ctx.rect(cx - ODpx/2, yTop, ODpx, tpx);
  ctx.fill();
  ctx.stroke();

  ctx.globalCompositeOperation = "destination-out";
  ctx.fillRect(cx - holeWpx/2, yTop, holeWpx, tpx);
  ctx.globalCompositeOperation = "source-over";
  ctx.restore();
}

function drawBearingFace(ctx, cx, yAt, faceW, holeW){
  ctx.save();
  ctx.strokeStyle = "#4b5563";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(cx - faceW/2, yAt);
  ctx.lineTo(cx - holeW/2, yAt);
  ctx.moveTo(cx + holeW/2, yAt);
  ctx.lineTo(cx + faceW/2, yAt);
  ctx.stroke();
  ctx.restore();
}

function drawThreadStartMarker(ctx, cx, y, shankW, color="#111827"){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1.25;
  ctx.beginPath();
  ctx.moveTo(cx - shankW*0.65, y);
  ctx.lineTo(cx + shankW*0.65, y);
  ctx.stroke();
  ctx.restore();
}

function drawDimBracket(ctx, x, y0, y1, label, color="#111827"){
  const top = Math.min(y0,y1), bot = Math.max(y0,y1);
  const cap = 7;

  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 1;

  ctx.beginPath();
  ctx.moveTo(x, top);
  ctx.lineTo(x, bot);
  ctx.moveTo(x-cap, top);
  ctx.lineTo(x+cap, top);
  ctx.moveTo(x-cap, bot);
  ctx.lineTo(x+cap, bot);
  ctx.stroke();

  ctx.font = "13px system-ui";
  ctx.textBaseline = "middle";
  ctx.fillText(label, x + 10, (top+bot)/2);
  ctx.restore();
}

function drawArrow(ctx, x1,y1,x2,y2, color="#111827"){
  ctx.save();
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 2;

  ctx.beginPath();
  ctx.moveTo(x1,y1);
  ctx.lineTo(x2,y2);
  ctx.stroke();

  const ang = Math.atan2(y2-y1, x2-x1);
  const head = 10;
  ctx.beginPath();
  ctx.moveTo(x2,y2);
  ctx.lineTo(x2 - head*Math.cos(ang - Math.PI/6), y2 - head*Math.sin(ang - Math.PI/6));
  ctx.lineTo(x2 - head*Math.cos(ang + Math.PI/6), y2 - head*Math.sin(ang + Math.PI/6));
  ctx.closePath();
  ctx.fill();

  ctx.restore();
}

/* ============================================================
   Event wiring
   ============================================================ */
function recalcAndDraw(runSolve){
  updateRightPills();
  const state = readState();
  const geom = deriveGeometry(state);
  if(geom) drawJoint(state, geom);
  if(runSolve) runSolveForCurrentSelection();
}

function resetDefaults(){
  $("isImperial").checked = true;

  rebuildBoltFamilyOptions();
  rebuildGradeOptions();
  $("threadSeries").value = "coarse";
  rebuildSizeOptions();

  $("useHeadWasher").value = "yes";
  $("tHeadWasher").value = "0.06";
  $("odHeadWasher").value = "1.00";
  $("matHeadWasher").value = "steel";

  $("numMembers").value = "2";
  buildMemberRows();

  $("useNutWasher").value = "yes";
  $("tNutWasher").value = "0.06";
  $("odNutWasher").value = "1.00";
  $("matNutWasher").value = "steel";

  $("Lshank").value = "0.75";

  $("Pext").value = "2000";
  $("Ttarget").value = "120";
  $("Ttol").value = "10";
  $("muTmin").value = "0.12";
  $("muTmax").value = "0.20";
  $("muBmin").value = "0.12";
  $("muBmax").value = "0.20";

  $("holeFit").value = "normal";
  $("holeDia").value = "";

  $("proofLimit").value = "1.00";
  $("frustumAngle").value = "30";
  $("torqueAt").value = "nut";
  $("etaThread").value = "0.90";
  updateBoltEDefault();

  setStatus("Ready", "ok");
  recalcAndDraw(false);
}

/* ============================================================
   Export/Import Functions
   ============================================================ */

function exportStateAsJSON() {
  const state = readState();
  
  // Capture all input values for restoration
  const exportData = {
    version: "1.0",
    timestamp: new Date().toISOString(),
    units: {
      isImperial: $("isImperial").checked
    },
    bolt: {
      family: $("boltFamily").value,
      threadSeries: $("threadSeries").value,
      grade: $("boltGrade").value,
      size: $("boltSize").value,
      boltE: $("boltE").value,
      etaThread: $("etaThread").value,
      frustumAngle: $("frustumAngle").value
    },
    geometry: {
      useHeadWasher: $("useHeadWasher").value,
      tHeadWasher: $("tHeadWasher").value,
      odHeadWasher: $("odHeadWasher").value,
      matHeadWasher: $("matHeadWasher").value,
      
      numMembers: $("numMembers").value,
      members: [],
      
      useNutWasher: $("useNutWasher").value,
      tNutWasher: $("tNutWasher").value,
      odNutWasher: $("odNutWasher").value,
      matNutWasher: $("matNutWasher").value,
      
      Lshank: $("Lshank").value
    },
    loads: {
      P: $("Pext").value,
      T: $("Ttarget").value,
      torqueAt: $("torqueAt").value,
      Ttol: $("Ttol").value,
      muTmin: $("muTmin").value,
      muTmax: $("muTmax").value,
      muBmin: $("muBmin").value,
      muBmax: $("muBmax").value,
      holeFit: $("holeFit").value,
      holeDia: $("holeDia").value,
      proofLimit: $("proofLimit").value
    }
  };
  
  // Capture member data
  const nMembers = Number($("numMembers").value);
  for(let i = 1; i <= nMembers; i++) {
    exportData.geometry.members.push({
      t: $("m_t_" + i).value,
      mat: $("m_mat_" + i).value,
      extra: $("m_extra_" + i).value
    });
  }
  
  // Create and download JSON file
  const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `bolted-joint-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  setStatus("JSON exported", "ok");
}

function importStateFromJSON() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const data = JSON.parse(event.target.result);
        
        // Restore units
        $("isImperial").checked = data.units.isImperial;
        
        // Trigger rebuild of family/grade/size dropdowns
        rebuildBoltFamilyOptions();
        
        // Restore bolt settings
        $("boltFamily").value = data.bolt.family;
        rebuildGradeOptions();
        
        $("threadSeries").value = data.bolt.threadSeries;
        rebuildSizeOptions();
        
        $("boltGrade").value = data.bolt.grade;
        $("boltSize").value = data.bolt.size;
        $("boltE").value = data.bolt.boltE;
        $("etaThread").value = data.bolt.etaThread;
        $("frustumAngle").value = data.bolt.frustumAngle;
        
        // Restore geometry
        $("useHeadWasher").value = data.geometry.useHeadWasher;
        $("tHeadWasher").value = data.geometry.tHeadWasher;
        $("odHeadWasher").value = data.geometry.odHeadWasher;
        $("matHeadWasher").value = data.geometry.matHeadWasher;
        
        $("useNutWasher").value = data.geometry.useNutWasher;
        $("tNutWasher").value = data.geometry.tNutWasher;
        $("odNutWasher").value = data.geometry.odNutWasher;
        $("matNutWasher").value = data.geometry.matNutWasher;
        $("Lshank").value = data.geometry.Lshank;
        
        // Restore loads
        $("Pext").value = data.loads.P;
        $("Ttarget").value = data.loads.T;
        $("torqueAt").value = data.loads.torqueAt;
        $("Ttol").value = data.loads.Ttol;
        $("muTmin").value = data.loads.muTmin;
        $("muTmax").value = data.loads.muTmax;
        $("muBmin").value = data.loads.muBmin;
        $("muBmax").value = data.loads.muBmax;
        $("holeFit").value = data.loads.holeFit;
        $("holeDia").value = data.loads.holeDia;
        $("proofLimit").value = data.loads.proofLimit;
        
        // Handle members - need to build rows with correct data
        $("numMembers").value = data.geometry.numMembers;
        buildMemberRowsWithData(data.geometry.members);
        
        recalcAndDraw(true);
        setStatus("JSON imported", "ok");
        
      } catch (err) {
        setStatus("Import failed: " + err.message, "err");
        console.error("Import error:", err);
      }
    };
    reader.readAsText(file);
  };
  
  input.click();
}

function exportSummaryAsCSV() {
  const state = readState();
  const ev = evaluateCurrentBolt(state);
  
  if (!ev.geom) {
    setStatus("No data to export", "err");
    return;
  }
  
  const u = state.u;
  const now = new Date();
  const dateStr = now.toISOString().slice(0, 19).replace('T', ' ');
  
  // Build CSV content
  let csv = "Bolted Joint Analysis Summary\n";
  csv += `Export Date/Time,${dateStr}\n`;
  csv += `\n`;
  
  // Configuration section
  csv += "CONFIGURATION\n";
  csv += `Units,${state.units === "imperial" ? "Imperial" : "Metric"}\n`;
  csv += `Bolt Family,${$("boltFamily").value}\n`;
  csv += `Thread Series,${$("threadSeries").value}\n`;
  csv += `Grade,${$("boltGrade").value}\n`;
  csv += `Bolt Size,${state.bolt.data?.label || "—"}\n`;
  csv += `\n`;
  
  // Input parameters
  csv += "INPUT PARAMETERS\n";
  csv += `External Load P,${state.loads.P},${u.F}\n`;
  csv += `Target Torque T,${state.loads.T},${u.T}\n`;
  csv += `Torque Tolerance,${(state.loads.TtolPct * 100).toFixed(1)},%\n`;
  csv += `Grip Length Lg,${fmt(ev.geom.Lg)},${u.L}\n`;
  csv += `Shank Length in Grip,${fmt(ev.geom.Lsh)},${u.L}\n`;
  csv += `Thread Length in Grip,${fmt(ev.geom.Lth)},${u.L}\n`;
  csv += `\n`;
  
  // Results section
  csv += "ANALYSIS RESULTS\n";
  csv += `Quantity,Value,Units\n`;
  csv += `Clearance Hole Diameter,${fmt(ev.geom.dh)},${u.L}\n`;
  csv += `Hole Fit,${state.loads.holeFit}\n`;
  csv += `Torque Applied At,${state.loads.torqueAt}\n`;
  csv += `Effective Bearing Diameter,${fmt(ev.preload?.Db_eff)},${u.L}\n`;
  csv += `Shank Area,${fmt(ev.kbOut?.A_shank)},${u.L}²\n`;
  csv += `Tensile Stress Area,${fmt(ev.kbOut?.At)},${u.L}²\n`;
  csv += `Thread Compliance Factor,${fmt(ev.kbOut?.eta, 3)}\n`;
  csv += `Effective Thread Area,${fmt(ev.kbOut?.At_eff)},${u.L}²\n`;
  csv += `Bolt Stiffness kb,${fmt(ev.kbOut?.kb)},${u.F}/${u.L}\n`;
  csv += `Member Stiffness km,${fmt(ev.kmOut?.km)},${u.F}/${u.L}\n`;
  csv += `Load Fraction C,${fmt(ev.C, 5)}\n`;
  csv += `Torque Min,${fmt(ev.preload?.Tmin)},${u.T}\n`;
  csv += `Torque Max,${fmt(ev.preload?.Tmax)},${u.T}\n`;
  csv += `Preload Min,${fmt(ev.preload?.Fmin)},${u.F}\n`;
  csv += `Preload Max,${fmt(ev.preload?.Fmax)},${u.F}\n`;
  csv += `Separation Requirement,${fmt(ev.sepReq)},${u.F}\n`;
  csv += `Separation Margin,${fmt(ev.sepMargin)},${u.F}\n`;
  csv += `Proof Load,${fmt(ev.Fproof)},${u.F}\n`;
  csv += `Max Bolt Load,${fmt(ev.FbMax)},${u.F}\n`;
  csv += `Proof Margin,${fmt(ev.proofMargin)},${u.F}\n`;
  csv += `\n`;
  
  // Status
  let status = "OK";
  if (ev.sepMargin != null && ev.sepMargin < 0) status = "FAIL - Separation";
  else if (ev.proofMargin != null && ev.proofMargin < 0) status = "FAIL - Over Proof";
  else if (ev.sepMargin != null && ev.sepMargin < 0.05 * Math.max(1, ev.sepReq || 1)) status = "WARNING - Low Separation Margin";
  
  csv += `Overall Status,${status}\n`;
  
  // Create and download CSV file
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `bolted-joint-summary-${now.toISOString().slice(0, 19).replace(/:/g, '-')}.csv`;
  a.click();
  URL.revokeObjectURL(url);
  
  setStatus("CSV exported", "ok");
}



function bindEvents(){
  $("isImperial").addEventListener("change", ()=>{
    rebuildBoltFamilyOptions();
    rebuildGradeOptions();
    rebuildSizeOptions();
    updateBoltEDefault();

    if($("isImperial").checked){
      $("tHeadWasher").value = "0.06";
      $("odHeadWasher").value = "1.00";
      $("tNutWasher").value = "0.06";
      $("odNutWasher").value = "1.00";
      $("Lshank").value = "0.75";
      $("Pext").value = "2000";
      $("Ttarget").value = "120";
    } else {
      $("tHeadWasher").value = "1.5";
      $("odHeadWasher").value = "24";
      $("tNutWasher").value = "1.5";
      $("odNutWasher").value = "24";
      $("Lshank").value = "20";
      $("Pext").value = "9000";
      $("Ttarget").value = "14000";
    }

    recalcAndDraw(false);
  });

  $("boltFamily").addEventListener("change", ()=>{
    rebuildGradeOptions();
    rebuildSizeOptions();
    updateBoltEDefault();
    recalcAndDraw(false);
  });

  $("threadSeries").addEventListener("change", ()=>{
    rebuildSizeOptions();
    recalcAndDraw(false);
  });

  $("boltGrade").addEventListener("change", ()=>recalcAndDraw(false));
  $("boltSize").addEventListener("change", ()=>recalcAndDraw(false));

  [
    "useHeadWasher","tHeadWasher","odHeadWasher","matHeadWasher",
    "useNutWasher","tNutWasher","odNutWasher","matNutWasher",
    "Lshank","frustumAngle","boltE","etaThread"
  ].forEach(id=>{
    $(id).addEventListener("input", ()=>recalcAndDraw(false));
    $(id).addEventListener("change", ()=>recalcAndDraw(false));
  });

  $("numMembers").addEventListener("change", ()=>{
    buildMemberRows();
    recalcAndDraw(false);
  });

  ["Pext","Ttarget","torqueAt","Ttol","muTmin","muTmax","muBmin","muBmax","holeFit","holeDia","proofLimit"]
    .forEach(id=>{
      $(id).addEventListener("input", ()=>recalcAndDraw(false));
      $(id).addEventListener("change", ()=>recalcAndDraw(false));
    });

  $("btnSolve").addEventListener("click", runSolveForCurrentSelection);
  $("btnRedraw").addEventListener("click", ()=>recalcAndDraw(false));
  $("btnReset").addEventListener("click", resetDefaults);

  $("btnScan").addEventListener("click", runSizeScan);


$("btnExportJSON").addEventListener("click", exportStateAsJSON);
  $("btnImportJSON").addEventListener("click", importStateFromJSON);
  $("btnExportCSV").addEventListener("click", exportSummaryAsCSV);



}

/* ============================================================
   Init
   ============================================================ */
(function init(){
  buildMaterialsSelect($("matHeadWasher"));
  buildMaterialsSelect($("matNutWasher"));
  $("matHeadWasher").value = "steel";
  $("matNutWasher").value = "steel";

  rebuildBoltFamilyOptions();
  rebuildGradeOptions();
  rebuildSizeOptions();
  updateBoltEDefault();

  buildMemberRows();
  bindEvents();
  resetDefaults();
})();

function evaluateCurrentBolt(state){
  const geom = deriveGeometry(state);
  if(!geom || !state.bolt.data) return { ok:false, reason:"No bolt/geometry" };

  const kbOut = calcBoltStiffness(state, geom);
  const kmOut = calcMemberStiffnessShigley(state, geom);
  const C = (kbOut.kb + kmOut.km) > 0 ? kbOut.kb/(kbOut.kb + kmOut.km) : null;

  const preload = calcPreloadBoundsThreadBearing(state, geom);
  const Fproof = calcProofLoad(state);

  const P = state.loads.P;
  const sepReq = (C!=null) ? (1-C)*P : null;
  const sepMargin = (preload?.Fmin!=null && sepReq!=null) ? (preload.Fmin - sepReq) : null;

  const FbMax = (preload?.Fmax!=null && C!=null) ? (preload.Fmax + C*P) : null;
  const proofMargin = (Fproof!=null && FbMax!=null) ? (state.loads.proofLimit*Fproof - FbMax) : null;

  const okSep = (sepMargin==null) ? false : (sepMargin >= 0);
  const okProof = (proofMargin==null) ? false : (proofMargin >= 0);
  const ok = okSep && okProof;

  return { ok, geom, kbOut, kmOut, C, preload, Fproof, sepReq, sepMargin, FbMax, proofMargin };
}

function runSizeScan(){
  const base = readState();
  const family = base.bolt.family;
  const series = base.bolt.series;

  const list = (BOLTS[family] && BOLTS[family][series]) ? BOLTS[family][series] : [];
  if(!list.length){
    setStatus("No sizes to scan", "err");
    return;
  }

  const holeOverride = base.loads.holeDiaOverride;

  let bestIdx = null;
  let bestBand = null;

  for(let idx=0; idx<list.length; idx++){
    const state = JSON.parse(JSON.stringify(base));
    state.bolt.sizeIdx = idx;
    state.bolt.data = list[idx];
    state.loads.holeDiaOverride = holeOverride;

    const geom = deriveGeometry(state);
    if(!geom) continue;

    const band = torqueBandForState(state, geom);
    if(band.feasible){
      bestIdx = idx;
      bestBand = band;
      break;
    }
  }

  if(bestIdx === null){
    setStatus("No passing size (scan)", "err");
    return;
  }

  $("boltSize").value = String(bestIdx);
  updateRightPills();

  if(bestBand?.Tset != null){
    $("Ttarget").value = String(bestBand.Tset);
  }

  runSolveForCurrentSelection();
  setStatus(`Scan OK → ${list[bestIdx].label}`, "ok");
}
</script>
</body>
</html>

















